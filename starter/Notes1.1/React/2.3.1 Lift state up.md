Great question, Vatan!

Letâ€™s go **brain-friendly** and explain:

> **How "lifting state up" helps avoid unnecessary re-renders**
> (especially for child components)

---

## ğŸ§  What is â€œLifting State Upâ€?

It means:
ğŸ‘‰ Move the `useState` **upward** to a common parent, so that:

* Shared data lives in one place
* Updates donâ€™t force unrelated components to re-render

---

## ğŸ’¥ Problem Scenario (State in Parent Causes Unwanted Re-renders)

Letâ€™s look at this example:

```jsx
function Parent() {
  const [count, setCount] = useState(0);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Click Me</button>
      <Child />
    </>
  );
}

function Child() {
  console.log("Child rendered");
  return <div>Iâ€™m the child!</div>;
}
```

### âŒ Problem:

* `count` only affects the button
* But every time `count` changes â†’ `Parent` re-renders â†’ `Child` re-renders too

---

## âœ… Solution: Lift State **Below** the Child (If Possible)

Instead of placing state in the parent of both, **move it to a component that only affects what's needed**.

### ğŸ” Option 1: Move State Outside `Parent` (Like to App or Sibling)

But in our case, **we can do better** by moving state to a component **that doesn't wrap `Child`**.

---

## âœ… Working Example Using Lifted State

Letâ€™s break the components apart:

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  console.log("Counter rendered");

  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}

function Child() {
  console.log("Child rendered");
  return <div>Iâ€™m the child!</div>;
}

function Parent() {
  return (
    <>
      <Counter />
      <Child />
    </>
  );
}
```

### âœ… Now what happens?

* `Counter` renders when `count` changes
* `Child` never re-renders because it's **not affected at all**
* ğŸ‰ **Problem solved without needing `React.memo()`**

---

## ğŸ¤– Why This Works?

Reactâ€™s render model is:

> â€œRe-render a component when its own state or props change.â€

By **moving state away from `Parent`**, we **avoid pulling `Child` into unnecessary re-renders**.

---

## ğŸ‘¨â€ğŸ« TL;DR - Lifting State Up to Optimize Performance

| Concept                                             | Description                                                        |
| --------------------------------------------------- | ------------------------------------------------------------------ |
| âŒ State in `Parent`                                 | Causes all children to re-render                                   |
| âœ… State in specific sub-component (lift up or down) | Keeps unrelated components untouched                               |
| ğŸ§  Use when                                         | You want to isolate updates to avoid wasted renders                |
| âœ… Bonus                                             | Combine with `React.memo()` for extra performance in complex trees |

---

Let me know if you want:

* ğŸ”§ A case where two children share state â€” and lifting helps
* ğŸ¯ Or a visual diff with timing to measure render impact

Want to go deeper into React render phases or memoization tricks next?
