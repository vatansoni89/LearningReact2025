### Set 1

Great! I’ll now begin giving you **JavaScript interview questions** with:

* ✅ Clear question
* ✅ ✅ Full answer
* ✅ ✅ ✅ Sample code for every explanation

Let’s start with a **batch of 10**, and I’ll continue in future batches with your confirmation.

---

### 🔥 JavaScript Interview Set #1: **Hoisting, Scope, Closures**

---

### **Q1: What is hoisting in JavaScript?**

#### ✅ Answer:

Hoisting is JavaScript's behavior of moving **declarations** (not initializations) to the top of their scope during compile phase.

#### ✅ Sample:

```js
console.log(a); // undefined
var a = 10;
```

Behind the scenes:

```js
var a;
console.log(a); // undefined
a = 10;
```

`let` and `const` are also hoisted but kept in a **Temporal Dead Zone (TDZ)** — accessing them before declaration throws error.

---

### **Q2: Difference between `var`, `let`, and `const`?**

| Feature   | `var`           | `let`       | `const`       |
| --------- | --------------- | ----------- | ------------- |
| Scope     | Function        | Block       | Block         |
| Hoisting  | Yes (undefined) | Yes (TDZ)   | Yes (TDZ)     |
| Redeclare | Allowed         | Not allowed | Not allowed   |
| Reassign  | Allowed         | Allowed     | ❌ Not allowed |

#### ✅ Sample:

```js
function test() {
  if (true) {
    var a = 1;
    let b = 2;
    const c = 3;
  }
  console.log(a); // 1
  console.log(b); // ReferenceError
  console.log(c); // ReferenceError
}
test();
```

---

### **Q3: What is Temporal Dead Zone (TDZ)?**

#### ✅ Answer:

TDZ is the time between entering a scope and the point where a variable is declared. Accessing a `let` or `const` before its declaration in this zone throws a ReferenceError.

#### ✅ Sample:

```js
console.log(a); // ❌ ReferenceError
let a = 10;
```

---

### **Q4: Function Declaration vs Function Expression in Hoisting**

#### ✅ Answer:

* **Function declarations** are hoisted **with their body**.
* **Function expressions** (assigned to `var`, `let`, or `const`) are not fully hoisted.

#### ✅ Sample:

```js
sayHello(); // ✅ Works
function sayHello() {
  console.log("Hi");
}

sayHi(); // ❌ TypeError: sayHi is not a function
var sayHi = function() {
  console.log("Hi");
};
```

---

### **Q5: What is a closure in JavaScript?**

#### ✅ Answer:

A closure is when a function “remembers” variables from its **lexical scope**, even when the outer function has finished executing.

#### ✅ Sample:

```js
function outer() {
  let count = 0;
  return function inner() {
    count++;
    console.log(count);
  };
}
const counter = outer();
counter(); // 1
counter(); // 2
```

Even after `outer()` has completed, `inner()` still has access to `count`.

---

### **Q6: Use closure to create a private counter**

#### ✅ Sample:

```js
function createCounter() {
  let count = 0;
  return {
    increment: function () {
      count++;
      console.log(count);
    },
    decrement: function () {
      count--;
      console.log(count);
    }
  };
}
const counter = createCounter();
counter.increment(); // 1
counter.increment(); // 2
counter.decrement(); // 1
```

Here `count` is private and cannot be accessed directly.

---

### **Q7: Explain lexical scope with example**

#### ✅ Answer:

Lexical scope means scope is determined by **where variables and functions are written in code**, not where they are called from.

#### ✅ Sample:

```js
function outer() {
  let name = "Vatan";
  function inner() {
    console.log(name); // has access to outer's variables
  }
  inner();
}
outer();
```

---

### **Q8: What is an IIFE and when is it used?**

#### ✅ Answer:

IIFE = Immediately Invoked Function Expression. It's used to create a private scope and avoid polluting global variables.

#### ✅ Sample:

```js
(function () {
  let secret = "I'm private";
  console.log(secret);
})(); // Outputs: I'm private

console.log(secret); // ❌ ReferenceError
```

---

### **Q9: What will this print and why?**

```js
function outer() {
  let a = 5;
  return function inner() {
    console.log(a);
  };
}
outer()();
```

#### ✅ Output:

```
5
```

Because `inner` is a closure — it remembers `a` from `outer()` even after it's returned.

---

### **Q10: Arrow function vs regular function in terms of `this`?**

#### ✅ Answer:

Arrow functions do not have their own `this`. They inherit `this` from their surrounding scope.

#### ✅ Sample:

```js
const obj = {
  name: "Devpriyaa",
  say: function () {
    setTimeout(() => {
      console.log(this.name); // ✅ 'Devpriyaa'
    }, 100);
  }
};
obj.say();
```

Had we used regular function in setTimeout, `this.name` would be `undefined`.

---

### Set 2

Awesome, Vatan! Let’s jump into **🔥 Set #2: Async, Event Loop, Promises** with **in-depth answers** and **sample code** for each concept.

---

## 🔥 JavaScript Interview Set #2: **Async, Event Loop, Promises**

---

### **Q11: What is the JavaScript event loop?**

#### ✅ Answer:

The **event loop** allows JavaScript (which is single-threaded) to perform **non-blocking** async operations by using:

* **Call Stack**
* **Web APIs**
* **Callback Queue (Macrotask queue)**
* **Microtask Queue (Promise callbacks)**

#### ✅ Sample:

```js
console.log('Start');

setTimeout(() => console.log('Timeout'), 0);

Promise.resolve().then(() => console.log('Promise'));

console.log('End');
```

#### ✅ Output:

```
Start
End
Promise
Timeout
```

* Sync runs first (`Start`, `End`)
* Microtask (`Promise`) comes before macrotask (`setTimeout`)

---

### **Q12: Microtask vs Macrotask**

| Feature  | Microtask Queue                  | Macrotask Queue                             |
| -------- | -------------------------------- | ------------------------------------------- |
| Priority | Higher                           | Lower                                       |
| Examples | `Promise.then`, `queueMicrotask` | `setTimeout`, `setInterval`, `setImmediate` |

Microtasks execute **after the current script but before any macrotask**.

---

### **Q13: What does `setTimeout(..., 0)` really mean?**

#### ✅ Answer:

Even with 0ms delay, `setTimeout` runs after the current stack and microtasks. It’s a **macrotask**, so it doesn’t interrupt synchronous code.

#### ✅ Sample:

```js
setTimeout(() => console.log('setTimeout'), 0);
Promise.resolve().then(() => console.log('Promise'));
console.log('Sync');
```

#### ✅ Output:

```
Sync
Promise
setTimeout
```

---

### **Q14: Explain `Promise.all` vs `Promise.race`**

#### ✅ Answer:

| Method         | Behavior                                                     |
| -------------- | ------------------------------------------------------------ |
| `Promise.all`  | Waits for all to **resolve** or **rejects** if any one fails |
| `Promise.race` | Resolves/rejects as soon as **any one finishes**             |

#### ✅ Sample:

```js
const p1 = new Promise(res => setTimeout(() => res('one'), 100));
const p2 = new Promise(res => setTimeout(() => res('two'), 50));

Promise.all([p1, p2]).then(console.log); // ['one', 'two']
Promise.race([p1, p2]).then(console.log); // 'two'
```

---

### **Q15: What does `async` keyword do to a function?**

#### ✅ Answer:

It makes the function always return a **promise**. Inside it, you can use `await` to pause execution until a promise resolves.

#### ✅ Sample:

```js
async function fetchName() {
  return "Devpriyaa";
}
fetchName().then(console.log); // Logs "Devpriyaa"
```

Even though we returned a string, it becomes a resolved promise automatically.

---

### **Q16: What's the difference between `await` and `.then()`?**

#### ✅ Answer:

| Feature | `.then()`                | `await`                       |
| ------- | ------------------------ | ----------------------------- |
| Syntax  | Promise chaining         | Sequential / synchronous-like |
| Use     | Outside `async` function | Only inside `async` function  |

#### ✅ Sample:

```js
function fetchData() {
  return Promise.resolve("Data");
}

// Using then()
fetchData().then(res => console.log(res));

// Using await
async function demo() {
  const data = await fetchData();
  console.log(data);
}
demo();
```

---

### **Q17: Can we use `await` outside of an `async` function?**

#### ✅ Answer:

No. It throws a `SyntaxError`. To use `await`, wrap it inside an `async` function or use top-level await in modern environments (ES2022+).

#### ✅ Sample:

```js
// ❌ This will error
// const data = await fetch();

// ✅ Fix
async function load() {
  const data = await fetch('...');
}
```

---

### **Q18: What is a callback hell and how to avoid it?**

#### ✅ Answer:

**Callback hell** happens when callbacks are nested deeply, making code unreadable.

#### ❌ Example:

```js
login(user, function () {
  fetchProfile(user, function () {
    updateUI(function () {
      // Callback hell
    });
  });
});
```

#### ✅ Fix: Use Promises or `async/await`

```js
async function doFlow() {
  await login(user);
  const profile = await fetchProfile(user);
  updateUI(profile);
}
```

---

### **Q19: Write a custom `delay(ms)` function using Promise**

#### ✅ Sample:

```js
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function test() {
  console.log("Waiting...");
  await delay(1000);
  console.log("Done!");
}
test();
```

---

### **Q20: What is the output of the following code?**

```js
console.log("1");
setTimeout(() => console.log("2"), 0);
Promise.resolve().then(() => console.log("3"));
console.log("4");
```

#### ✅ Output:

```
1
4
3
2
```

#### ✅ Why?

* 1 & 4: synchronous
* 3: microtask (promise)
* 2: macrotask (timeout)

---

### ✅ Summary Table of Key Concepts

| Concept               | Explanation                                         |
| --------------------- | --------------------------------------------------- |
| Event loop            | Processes stack → microtasks → macrotasks           |
| Microtask > Macrotask | Microtasks always execute first                     |
| Promises              | Allow chaining, async flow control                  |
| Async/await           | Syntactic sugar over Promises                       |
| setTimeout            | Adds macrotask to queue                             |
| Callback Hell         | Deep nesting of callbacks, avoid via Promises/await |

---

### Set 3

Perfect, Vatan! Here's **🔥 Set #3: Equality, Type Coercion & Weird Comparisons** — a key area for JS interviews because it tests your deep understanding of how JavaScript behaves under the hood.

---

## 🔥 JavaScript Interview Set #3: **Equality, Type Coercion, and Comparisons**

---

### **Q21: What is the difference between `==` and `===`?**

#### ✅ Answer:

| Operator | Name            | Behavior                         |
| -------- | --------------- | -------------------------------- |
| `==`     | Loose equality  | Converts types before comparison |
| `===`    | Strict equality | Compares **value + type**        |

#### ✅ Sample:

```js
console.log('2' == 2);  // true
console.log('2' === 2); // false
```

---

### **Q22: Why does `[] == false` return `true`?**

#### ✅ Answer:

Loose comparison → coercion happens:

```js
[] == false
→ ToPrimitive([]) → ''
→ '' == false
→ 0 == 0 → ✅ true
```

#### ✅ Sample:

```js
console.log([] == false);  // true
console.log([] === false); // false
```

---

### **Q23: What is the result of this code and why?**

```js
console.log([] + []); // ?
console.log([] + {}); // ?
console.log({} + []); // ?
```

#### ✅ Output:

```js
""        // [] + [] → "" (empty strings)
"[object Object]" // [] + {} → string conversion
0         // {} + [] → treated as code block + array
```

#### ✅ Sample:

```js
console.log([] + []);          // ""
console.log([] + {});          // "[object Object]"
console.log({} + []);          // 0 (or "[object Object]" depending on syntax)
```

> The behavior of `{}` is context-sensitive — whether it’s treated as a block or an object literal.

---

### **Q24: What are falsy values in JavaScript?**

#### ✅ Falsy values:

```js
false
0
-0
0n
""
null
undefined
NaN
```

Everything else is **truthy**.

#### ✅ Sample:

```js
if ("") console.log("Yes");  // won't run
if ("hello") console.log("Hello"); // ✅ runs
```

---

### **Q25: What is the difference between `null` and `undefined`?**

| Feature  | `null`                       | `undefined`                  |
| -------- | ---------------------------- | ---------------------------- |
| Meaning  | Intentional absence of value | Uninitialized or missing     |
| Type     | `object`                     | `undefined`                  |
| Equality | `null == undefined` → true   | `null === undefined` → false |

#### ✅ Sample:

```js
let a;
console.log(a);        // undefined
let b = null;
console.log(b);        // null
console.log(a == b);   // true
console.log(a === b);  // false
```

---

### **Q26: Why is `typeof null === "object"`?**

#### ✅ Answer:

This is a **legacy bug** from the early days of JavaScript.

* Internally, null is represented as a **null pointer**, which was mistakenly tagged as an `object`.

#### ✅ Sample:

```js
console.log(typeof null); // "object" ❌ misleading
```

✅ Check for `null` using:

```js
if (value === null)
```

---

### **Q27: Is `NaN === NaN` true?**

#### ✅ Answer:

No. `NaN` is the **only value in JS that is not equal to itself**.

#### ✅ Sample:

```js
console.log(NaN === NaN); // false
console.log(Number.isNaN(NaN)); // true ✅
```

Always use `Number.isNaN()` instead of `x === NaN`.

---

### **Q28: How to check if a value is an array?**

#### ✅ Answer:

Use `Array.isArray(value)`.

#### ✅ Sample:

```js
const arr = [1, 2];
console.log(typeof arr);         // "object"
console.log(Array.isArray(arr)); // true ✅
```

---

### **Q29: What is type coercion?**

#### ✅ Answer:

Type coercion is JavaScript’s automatic or implicit **conversion of a value** from one type to another.

#### ✅ Sample:

```js
console.log('5' * 2); // 10 → '5' converted to number
console.log('5' + 2); // '52' → number converted to string
```

---

### **Q30: How to compare two objects properly?**

#### ✅ Answer:

Objects are compared by **reference**, not content.

To compare content, convert to strings or compare keys/values manually.

#### ✅ Sample:

```js
const obj1 = { name: 'Vatan' };
const obj2 = { name: 'Vatan' };

console.log(obj1 == obj2); // false
console.log(JSON.stringify(obj1) === JSON.stringify(obj2)); // true ✅
```

> Better approach: use deep equality functions (lodash `isEqual`, or custom).

---

### 🔁 Summary Table

| Expression          | Result        | Reason                         |
| ------------------- | ------------- | ------------------------------ |
| `'2' == 2`          | `true`        | Type coercion: string → number |
| `[] == false`       | `true`        | `[] → '' → 0 → false`          |
| `null == undefined` | `true`        | Only special loose equality    |
| `NaN === NaN`       | `false`       | NaN not equal to itself        |
| `typeof null`       | `"object"`    | Legacy bug                     |
| `[] + []`           | `""`          | Both become empty strings      |
| `{}` + `[]`         | `0` or object | Depends on context             |
| `Array.isArray([])` | `true`        | Correct way to detect arrays   |

---

### Set 4

Great choice, Vatan! Here's **🔥 Set #4: JavaScript Array Methods & Use Cases**, one of the most **practical** and **commonly asked areas** in interviews — especially with real-life use cases in React and backend logic.

---

## 🔥 JavaScript Interview Set #4: **Array Methods (map, filter, reduce, etc.)**

---

### **Q31: What is the difference between `.map()` and `.forEach()`?**

| Feature   | `map()`            | `forEach()`          |
| --------- | ------------------ | -------------------- |
| Returns   | New array          | `undefined`          |
| Use case  | Transform & return | Perform side-effects |
| Chainable | ✅ Yes              | ❌ No                 |

#### ✅ Sample:

```js
const nums = [1, 2, 3];

// map
const doubled = nums.map(n => n * 2); // [2, 4, 6]

// forEach
const output = [];
nums.forEach(n => output.push(n * 2)); // modifies output array
```

---

### **Q32: What does `.reduce()` do in JavaScript?**

#### ✅ Answer:

`.reduce()` iterates through the array and **accumulates a result** based on logic you define.

#### ✅ Sample: Sum of numbers

```js
const nums = [1, 2, 3, 4];
const sum = nums.reduce((acc, curr) => acc + curr, 0);
console.log(sum); // 10
```

---

### **Q33: Filter out duplicate items from an array**

#### ✅ Sample:

```js
const nums = [1, 2, 2, 3, 4, 4];
const unique = [...new Set(nums)];
console.log(unique); // [1, 2, 3, 4]
```

OR using `reduce`:

```js
const unique2 = nums.reduce((acc, curr) => {
  if (!acc.includes(curr)) acc.push(curr);
  return acc;
}, []);
```

---

### **Q34: How to flatten a nested array?**

#### ✅ Sample:

```js
const nested = [1, [2, [3, [4]]]];
const flat = nested.flat(Infinity); // [1, 2, 3, 4]
```

Without `.flat()`:

```js
function flatten(arr) {
  return arr.reduce((acc, curr) => 
    acc.concat(Array.isArray(curr) ? flatten(curr) : curr), []);
}
```

---

### **Q35: Sort array of objects by salary descending**

#### ✅ Sample:

```js
const employees = [
  { name: 'A', salary: 120 },
  { name: 'B', salary: 100 },
  { name: 'C', salary: 150 }
];

employees.sort((a, b) => b.salary - a.salary);
```

---

### **Q36: Use `.some()` and `.every()` with examples**

#### ✅ `.some()` – does **any** item match?

```js
const nums = [1, 2, 3];
console.log(nums.some(n => n > 2)); // true
```

#### ✅ `.every()` – do **all** items match?

```js
console.log(nums.every(n => n > 0)); // true
```

---

### **Q37: Convert array to object using `.reduce()`**

#### ✅ Sample:

```js
const fruits = ['apple', 'banana', 'apple'];

const fruitCount = fruits.reduce((acc, fruit) => {
  acc[fruit] = (acc[fruit] || 0) + 1;
  return acc;
}, {});

console.log(fruitCount); // { apple: 2, banana: 1 }
```

---

### **Q38: Chain `.filter().map().reduce()` together**

#### ✅ Sample:

```js
const products = [
  { name: 'Pen', price: 10 },
  { name: 'Notebook', price: 50 },
  { name: 'Pencil', price: 5 }
];

const total = products
  .filter(p => p.price > 5)
  .map(p => p.price)
  .reduce((sum, price) => sum + price, 0);

console.log(total); // 60
```

---

### **Q39: How to use array destructuring with skipping?**

#### ✅ Sample:

```js
const arr = [1, 2, 3, 4];

const [, second, , fourth] = arr;

console.log(second); // 2
console.log(fourth); // 4
```

---

### **Q40: What’s the difference between Spread `...` and Rest `...` operators?**

#### ✅ Answer:

| Operator | Use case             | Example                |
| -------- | -------------------- | ---------------------- |
| Spread   | Expands array/object | `let copy = [...arr]`  |
| Rest     | Collects into array  | `function(...args) {}` |

#### ✅ Sample:

```js
const arr = [1, 2, 3];
const clone = [...arr]; // Spread

function sum(...args) {
  return args.reduce((a, b) => a + b);
}
console.log(sum(1, 2, 3)); // 6
```

---

### 🧠 Summary Table of Common Array Methods

| Method      | Purpose                        | Returns New Array?  |
| ----------- | ------------------------------ | ------------------- |
| `map()`     | Transform each item            | ✅ Yes               |
| `filter()`  | Keep items based on condition  | ✅ Yes               |
| `reduce()`  | Accumulate to single value     | ❌ No                |
| `forEach()` | Side-effects, no return needed | ❌ No                |
| `some()`    | Check if **any** match         | ❌ No (returns bool) |
| `every()`   | Check if **all** match         | ❌ No (returns bool) |
| `flat()`    | Flatten nested arrays          | ✅ Yes               |
| `find()`    | First match                    | ❌ Single item       |

---

### Set 5

Great choice, Vatan! Here's **🔥 Set #4: JavaScript Array Methods & Use Cases**, one of the most **practical** and **commonly asked areas** in interviews — especially with real-life use cases in React and backend logic.

---

## 🔥 JavaScript Interview Set #4: **Array Methods (map, filter, reduce, etc.)**

---

### **Q31: What is the difference between `.map()` and `.forEach()`?**

| Feature   | `map()`            | `forEach()`          |
| --------- | ------------------ | -------------------- |
| Returns   | New array          | `undefined`          |
| Use case  | Transform & return | Perform side-effects |
| Chainable | ✅ Yes              | ❌ No                 |

#### ✅ Sample:

```js
const nums = [1, 2, 3];

// map
const doubled = nums.map(n => n * 2); // [2, 4, 6]

// forEach
const output = [];
nums.forEach(n => output.push(n * 2)); // modifies output array
```

---

### **Q32: What does `.reduce()` do in JavaScript?**

#### ✅ Answer:

`.reduce()` iterates through the array and **accumulates a result** based on logic you define.

#### ✅ Sample: Sum of numbers

```js
const nums = [1, 2, 3, 4];
const sum = nums.reduce((acc, curr) => acc + curr, 0);
console.log(sum); // 10
```

---

### **Q33: Filter out duplicate items from an array**

#### ✅ Sample:

```js
const nums = [1, 2, 2, 3, 4, 4];
const unique = [...new Set(nums)];
console.log(unique); // [1, 2, 3, 4]
```

OR using `reduce`:

```js
const unique2 = nums.reduce((acc, curr) => {
  if (!acc.includes(curr)) acc.push(curr);
  return acc;
}, []);
```

---

### **Q34: How to flatten a nested array?**

#### ✅ Sample:

```js
const nested = [1, [2, [3, [4]]]];
const flat = nested.flat(Infinity); // [1, 2, 3, 4]
```

Without `.flat()`:

```js
function flatten(arr) {
  return arr.reduce((acc, curr) => 
    acc.concat(Array.isArray(curr) ? flatten(curr) : curr), []);
}
```

---

### **Q35: Sort array of objects by salary descending**

#### ✅ Sample:

```js
const employees = [
  { name: 'A', salary: 120 },
  { name: 'B', salary: 100 },
  { name: 'C', salary: 150 }
];

employees.sort((a, b) => b.salary - a.salary);
```

---

### **Q36: Use `.some()` and `.every()` with examples**

#### ✅ `.some()` – does **any** item match?

```js
const nums = [1, 2, 3];
console.log(nums.some(n => n > 2)); // true
```

#### ✅ `.every()` – do **all** items match?

```js
console.log(nums.every(n => n > 0)); // true
```

---

### **Q37: Convert array to object using `.reduce()`**

#### ✅ Sample:

```js
const fruits = ['apple', 'banana', 'apple'];

const fruitCount = fruits.reduce((acc, fruit) => {
  acc[fruit] = (acc[fruit] || 0) + 1;
  return acc;
}, {});

console.log(fruitCount); // { apple: 2, banana: 1 }
```

---

### **Q38: Chain `.filter().map().reduce()` together**

#### ✅ Sample:

```js
const products = [
  { name: 'Pen', price: 10 },
  { name: 'Notebook', price: 50 },
  { name: 'Pencil', price: 5 }
];

const total = products
  .filter(p => p.price > 5)
  .map(p => p.price)
  .reduce((sum, price) => sum + price, 0);

console.log(total); // 60
```

---

### **Q39: How to use array destructuring with skipping?**

#### ✅ Sample:

```js
const arr = [1, 2, 3, 4];

const [, second, , fourth] = arr;

console.log(second); // 2
console.log(fourth); // 4
```

---

### **Q40: What’s the difference between Spread `...` and Rest `...` operators?**

#### ✅ Answer:

| Operator | Use case             | Example                |
| -------- | -------------------- | ---------------------- |
| Spread   | Expands array/object | `let copy = [...arr]`  |
| Rest     | Collects into array  | `function(...args) {}` |

#### ✅ Sample:

```js
const arr = [1, 2, 3];
const clone = [...arr]; // Spread

function sum(...args) {
  return args.reduce((a, b) => a + b);
}
console.log(sum(1, 2, 3)); // 6
```

---

### 🧠 Summary Table of Common Array Methods

| Method      | Purpose                        | Returns New Array?  |
| ----------- | ------------------------------ | ------------------- |
| `map()`     | Transform each item            | ✅ Yes               |
| `filter()`  | Keep items based on condition  | ✅ Yes               |
| `reduce()`  | Accumulate to single value     | ❌ No                |
| `forEach()` | Side-effects, no return needed | ❌ No                |
| `some()`    | Check if **any** match         | ❌ No (returns bool) |
| `every()`   | Check if **all** match         | ❌ No (returns bool) |
| `flat()`    | Flatten nested arrays          | ✅ Yes               |
| `find()`    | First match                    | ❌ Single item       |

---

### Set 5

Awesome, Vatan! Let’s dive into **🔥 Set #5: Functions, Scope, Closures, and Execution Context**, which is **core JavaScript** and heavily tested in interviews — especially for tricky debugging, closures in loops, and nested functions.

---

## 🔥 JavaScript Interview Set #5: **Functions, Scoping & Closures**

---

### **Q41: What is a Closure in JavaScript?**

#### ✅ Answer:

A **closure** is a function that remembers the variables from its **lexical scope**, even when the function is executed **outside that scope**.

#### ✅ Sample:

```js
function outer() {
  let counter = 0;
  return function inner() {
    counter++;
    console.log(counter);
  };
}

const fn = outer(); 
fn(); // 1
fn(); // 2
```

---

### **Q42: What is the output? Why?**

```js
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 0);
}
```

#### ✅ Output:

```
3
3
3
```

#### ✅ Why:

`var` is function-scoped. The value of `i` is shared and ends up being `3` after the loop finishes.

✅ Fix using `let`:

```js
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 0); // 0 1 2
}
```

✅ Fix using closure:

```js
for (var i = 0; i < 3; i++) {
  (function(j) {
    setTimeout(() => console.log(j), 0);
  })(i); // 0 1 2
}
```

---

### **Q43: Difference between Function Declaration vs Expression vs Arrow Function?**

| Type                 | Hoisted | `this` Binding | Syntax                    |
| -------------------- | ------- | -------------- | ------------------------- |
| Function Declaration | ✅ Yes   | Dynamic        | `function x(){}`          |
| Function Expression  | ❌ No    | Dynamic        | `const x = function() {}` |
| Arrow Function       | ❌ No    | Lexical        | `const x = () => {}`      |

---

### **Q44: Output & Explanation**

```js
console.log(x);
var x = 5;
```

#### ✅ Output:

`undefined`

#### ✅ Why:

Due to **hoisting**, `var x` is hoisted with value `undefined`. Only the declaration is hoisted, not the initialization.

---

### **Q45: Function returns another function – what happens?**

```js
function greet(name) {
  return function (msg) {
    console.log(`${msg}, ${name}`);
  };
}

const sayHi = greet('Vatan');
sayHi('Hello'); // Hello, Vatan
```

✅ This is a **closure** capturing the outer scope variable `name`.

---

### **Q46: Can we use default parameters in functions?**

#### ✅ Yes:

```js
function greet(name = 'Guest') {
  console.log(`Hello ${name}`);
}

greet(); // Hello Guest
```

---

### **Q47: Immediately Invoked Function Expression (IIFE) — use case?**

#### ✅ Sample:

```js
(function () {
  console.log('Runs immediately!');
})();
```

✅ Used to **create private scope** and avoid polluting global namespace.

---

### **Q48: Function hoisting — which will throw error?**

```js
hello(); // ✅ Works

function hello() {
  console.log('Hi');
}

hi(); // ❌ Error

const hi = function () {
  console.log('Hey');
};
```

---

### **Q49: What is a function's execution context?**

✅ It includes:

* **Variable Environment** (local variables)
* **Scope Chain**
* **`this` Binding**
* **Code to execute**

---

### **Q50: Create a counter using closure that can reset**

#### ✅ Sample:

```js
function createCounter() {
  let count = 0;
  return {
    increment() {
      count++;
      return count;
    },
    reset() {
      count = 0;
    }
  };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
counter.reset();
console.log(counter.increment()); // 1
```

---

## ✅ Summary Table

| Topic              | Core Idea                                   | Example or Use       |
| ------------------ | ------------------------------------------- | -------------------- |
| Closure            | Inner function remembers outer scope        | Loop fix, factory fn |
| IIFE               | Execute immediately, isolate scope          | Libraries, polyfills |
| Arrow vs Normal Fn | Arrow has lexical `this`                    | React handlers       |
| Hoisting           | `var` & function declarations hoisted       | `undefined` bugs     |
| Execution Context  | Variable + scope + `this` per function call | Call stack           |

---

Would you like **Set #6: `this`, Bind, Call, Apply, Arrow Function `this`**, or jump into **Async/Await, Promises, Event Loop debugging** next?

### Set 6

Perfect, Vatan! Now let’s dive into **🔥 Set #6: `this`, bind, call, apply, and arrow functions’ `this`**, which are **highly asked topics** for React, JS core, and system design interviews.

---

## 🔥 JavaScript Interview Set #6: **`this`, Arrow Functions, `bind`, `call`, `apply`**

---

### **Q51: What is `this` in JavaScript?**

#### ✅ Answer:

`this` refers to the **execution context** — the object that is calling the function.

#### ✅ Example:

```js
const person = {
  name: 'Vatan',
  greet() {
    console.log(`Hi, I'm ${this.name}`);
  },
};

person.greet(); // Hi, I'm Vatan
```

---

### **Q52: What does arrow function do to `this`?**

#### ✅ Answer:

Arrow functions **do not have their own `this`**, they use the **lexical `this`** (from their parent scope).

#### ✅ Example:

```js
const person = {
  name: 'Vatan',
  greet: function () {
    const arrow = () => {
      console.log(this.name); // Uses outer `this`
    };
    arrow();
  }
};

person.greet(); // Vatan
```

---

### **Q53: `this` inside a regular function vs arrow function**

```js
function test() {
  console.log(this);
}
const arrow = () => {
  console.log(this);
}

test();     // Window or undefined (strict mode)
arrow();    // `this` from outer scope (likely Window if top level)
```

✅ Arrow functions are great for:

* Callbacks (e.g., setTimeout, map)
* React `useEffect`, event handlers

---

### **Q54: Fix `this` loss in callback using arrow**

```js
const dog = {
  name: 'Rocky',
  bark() {
    setTimeout(() => {
      console.log(`${this.name} says woof!`);
    }, 1000);
  },
};

dog.bark(); // Rocky says woof!
```

✅ If you use a **normal function**, it loses `this`:

```js
setTimeout(function() {
  console.log(this.name); // undefined
}, 1000);
```

---

### **Q55: What is `bind()` in JavaScript?**

#### ✅ Answer:

`bind()` creates a new function with `this` bound to the specified object.

```js
const person = { name: 'Tanuja' };

function sayHello() {
  console.log(`Hello, ${this.name}`);
}

const greet = sayHello.bind(person);
greet(); // Hello, Tanuja
```

---

### **Q56: What are `call()` and `apply()`?**

#### ✅ Answer:

| Method    | Use `this` | Args Pass    |
| --------- | ---------- | ------------ |
| `call()`  | Yes        | Individually |
| `apply()` | Yes        | As array     |

```js
function intro(age) {
  console.log(`${this.name} is ${age} years old.`);
}

const user = { name: 'Devpriyaa' };

intro.call(user, 2);       // Devpriyaa is 2 years old.
intro.apply(user, [2]);    // Devpriyaa is 2 years old.
```

---

### **Q57: What is the difference between bind vs call vs apply?**

| Method    | Executes immediately | Returns new function | Argument Passing |
| --------- | -------------------- | -------------------- | ---------------- |
| `call()`  | ✅ Yes                | ❌ No                 | Normal args      |
| `apply()` | ✅ Yes                | ❌ No                 | Array            |
| `bind()`  | ❌ No (delayed)       | ✅ Yes                | Normal args      |

---

### **Q58: Arrow function can't be used as constructor — why?**

```js
const Dog = () => {};
const d = new Dog(); // ❌ TypeError
```

✅ Arrow functions **lack `[[Construct]]` method** so you can’t use them with `new`.

---

### **Q59: `this` inside object method with arrow**

```js
const obj = {
  name: "Vatan",
  greet: () => {
    console.log(this.name); // ❌ undefined
  }
};
obj.greet();
```

✅ Arrow doesn’t bind `this` — it’s taken from the outer scope, not the `obj`.

---

### **Q60: Create custom bind function**

```js
Function.prototype.myBind = function(context) {
  const fn = this;
  return function(...args) {
    return fn.apply(context, args);
  };
};

function greet(age) {
  console.log(`${this.name} is ${age}`);
}

const person = { name: "Vatan" };
const bound = greet.myBind(person);
bound(37); // Vatan is 37
```

---

## ✅ Summary Table

| Topic        | Key Point                                 | Tip                        |
| ------------ | ----------------------------------------- | -------------------------- |
| `this`       | Refers to caller object                   | `obj.method()` → `obj`     |
| `bind()`     | Returns new function with bound context   | Useful in React handlers   |
| `call()`     | Invokes immediately with specified `this` | args passed individually   |
| `apply()`    | Like call, but args in array              | Rarely used now            |
| Arrow `this` | Lexical (inherits from parent scope)      | Never use as object method |

---

Would you like **Set #7 on Promises, Async/Await, Event Loop**, or dive into **ES6 Features like Destructuring, Spread, Rest, and Object Enhancements** next?


### Set 7

Perfect, Vatan! Now let’s dive into **🔥 Set #6: `this`, bind, call, apply, and arrow functions’ `this`**, which are **highly asked topics** for React, JS core, and system design interviews.

---

## 🔥 JavaScript Interview Set #6: **`this`, Arrow Functions, `bind`, `call`, `apply`**

---

### **Q51: What is `this` in JavaScript?**

#### ✅ Answer:

`this` refers to the **execution context** — the object that is calling the function.

#### ✅ Example:

```js
const person = {
  name: 'Vatan',
  greet() {
    console.log(`Hi, I'm ${this.name}`);
  },
};

person.greet(); // Hi, I'm Vatan
```

---

### **Q52: What does arrow function do to `this`?**

#### ✅ Answer:

Arrow functions **do not have their own `this`**, they use the **lexical `this`** (from their parent scope).

#### ✅ Example:

```js
const person = {
  name: 'Vatan',
  greet: function () {
    const arrow = () => {
      console.log(this.name); // Uses outer `this`
    };
    arrow();
  }
};

person.greet(); // Vatan
```

---

### **Q53: `this` inside a regular function vs arrow function**

```js
function test() {
  console.log(this);
}
const arrow = () => {
  console.log(this);
}

test();     // Window or undefined (strict mode)
arrow();    // `this` from outer scope (likely Window if top level)
```

✅ Arrow functions are great for:

* Callbacks (e.g., setTimeout, map)
* React `useEffect`, event handlers

---

### **Q54: Fix `this` loss in callback using arrow**

```js
const dog = {
  name: 'Rocky',
  bark() {
    setTimeout(() => {
      console.log(`${this.name} says woof!`);
    }, 1000);
  },
};

dog.bark(); // Rocky says woof!
```

✅ If you use a **normal function**, it loses `this`:

```js
setTimeout(function() {
  console.log(this.name); // undefined
}, 1000);
```

---

### **Q55: What is `bind()` in JavaScript?**

#### ✅ Answer:

`bind()` creates a new function with `this` bound to the specified object.

```js
const person = { name: 'Tanuja' };

function sayHello() {
  console.log(`Hello, ${this.name}`);
}

const greet = sayHello.bind(person);
greet(); // Hello, Tanuja
```

---

### **Q56: What are `call()` and `apply()`?**

#### ✅ Answer:

| Method    | Use `this` | Args Pass    |
| --------- | ---------- | ------------ |
| `call()`  | Yes        | Individually |
| `apply()` | Yes        | As array     |

```js
function intro(age) {
  console.log(`${this.name} is ${age} years old.`);
}

const user = { name: 'Devpriyaa' };

intro.call(user, 2);       // Devpriyaa is 2 years old.
intro.apply(user, [2]);    // Devpriyaa is 2 years old.
```

---

### **Q57: What is the difference between bind vs call vs apply?**

| Method    | Executes immediately | Returns new function | Argument Passing |
| --------- | -------------------- | -------------------- | ---------------- |
| `call()`  | ✅ Yes                | ❌ No                 | Normal args      |
| `apply()` | ✅ Yes                | ❌ No                 | Array            |
| `bind()`  | ❌ No (delayed)       | ✅ Yes                | Normal args      |

---

### **Q58: Arrow function can't be used as constructor — why?**

```js
const Dog = () => {};
const d = new Dog(); // ❌ TypeError
```

✅ Arrow functions **lack `[[Construct]]` method** so you can’t use them with `new`.

---

### **Q59: `this` inside object method with arrow**

```js
const obj = {
  name: "Vatan",
  greet: () => {
    console.log(this.name); // ❌ undefined
  }
};
obj.greet();
```

✅ Arrow doesn’t bind `this` — it’s taken from the outer scope, not the `obj`.

---

### **Q60: Create custom bind function**

```js
Function.prototype.myBind = function(context) {
  const fn = this;
  return function(...args) {
    return fn.apply(context, args);
  };
};

function greet(age) {
  console.log(`${this.name} is ${age}`);
}

const person = { name: "Vatan" };
const bound = greet.myBind(person);
bound(37); // Vatan is 37
```

---

## ✅ Summary Table

| Topic        | Key Point                                 | Tip                        |
| ------------ | ----------------------------------------- | -------------------------- |
| `this`       | Refers to caller object                   | `obj.method()` → `obj`     |
| `bind()`     | Returns new function with bound context   | Useful in React handlers   |
| `call()`     | Invokes immediately with specified `this` | args passed individually   |
| `apply()`    | Like call, but args in array              | Rarely used now            |
| Arrow `this` | Lexical (inherits from parent scope)      | Never use as object method |

---

Would you like **Set #7 on Promises, Async/Await, Event Loop**, or dive into **ES6 Features like Destructuring, Spread, Rest, and Object Enhancements** next?


### Set 7

Absolutely, Vatan! 🔥 Here's your **JavaScript Interview Set #7**, covering **Promises, Async/Await, Event Loop, and Microtasks vs Macrotasks** — a very popular and confusing area in interviews.

---

## 🚦 Set #7: Promises, Async/Await, Microtask Queue, Event Loop

---

### **Q61: What is a Promise in JavaScript?**

#### ✅ Answer:

A `Promise` is an object that represents the **eventual completion (or failure)** of an async operation.

#### ✅ States:

* `pending`
* `fulfilled`
* `rejected`

#### ✅ Example:

```js
const fetchData = new Promise((resolve, reject) => {
  setTimeout(() => resolve("Success!"), 1000);
});

fetchData.then(result => console.log(result)); // After 1s → Success!
```

---

### **Q62: Chaining Promises**

```js
Promise.resolve(1)
  .then(x => x + 1)
  .then(x => x * 3)
  .then(console.log); // 6
```

✅ Each `then()` passes value to next. Each returns a new Promise.

---

### **Q63: What is Async/Await?**

#### ✅ Answer:

Syntactic sugar over Promises that allows writing asynchronous code in a **synchronous style**.

#### ✅ Example:

```js
async function loadData() {
  const result = await Promise.resolve("Loaded!");
  console.log(result);
}
loadData(); // Loaded!
```

---

### **Q64: Error Handling with Async/Await**

```js
async function fetchData() {
  try {
    const data = await Promise.reject("Something went wrong");
  } catch (error) {
    console.log(error); // Something went wrong
  }
}
```

---

### **Q65: What is the Event Loop?**

#### ✅ Answer:

The Event Loop is the mechanism that handles:

* Execution of synchronous code
* Deferment of async tasks (like timers, fetch)
* Executes Microtasks (like `Promise.then`)
* Executes Macrotasks (like `setTimeout`)

---

### **Q66: Microtasks vs Macrotasks**

| Type      | Example                     | Queue            |
| --------- | --------------------------- | ---------------- |
| Microtask | `.then`, `await`            | Runs **first**   |
| Macrotask | `setTimeout`, `setInterval` | After Microtasks |

```js
console.log(1);
setTimeout(() => console.log(2), 0);
Promise.resolve().then(() => console.log(3));
console.log(4);

// Output: 1, 4, 3, 2
```

✅ `Promise.then()` goes to **Microtask queue** and runs before `setTimeout`.

---

### **Q67: What is `Promise.all()`?**

#### ✅ Answer:

Waits for **all promises to fulfill** or **any one to reject**.

```js
Promise.all([
  Promise.resolve(1),
  Promise.resolve(2)
]).then(console.log); // [1, 2]
```

---

### **Q68: What is `Promise.race()`?**

#### ✅ Answer:

Returns the result of the **first settled (fulfilled or rejected)** promise.

```js
Promise.race([
  Promise.resolve("first"),
  new Promise(res => setTimeout(() => res("second"), 100))
]).then(console.log); // first
```

---

### **Q69: What is `Promise.any()`?**

✅ Resolves when **any one promise fulfills** (ignores rejections).

```js
Promise.any([
  Promise.reject("fail"),
  Promise.resolve("done"),
]).then(console.log); // done
```

---

### **Q70: How to create a custom delay Promise?**

```js
const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

async function waitAndSay() {
  await delay(1000);
  console.log("Waited 1 second");
}
waitAndSay();
```

---

## 🔁 Bonus: Event Loop Trap Interview Question

```js
console.log('start');

setTimeout(() => console.log('timeout'), 0);

Promise.resolve().then(() => console.log('promise'));

console.log('end');
```

✅ Output:

```
start
end
promise   ← microtask
timeout   ← macrotask
```

---

## 🧠 Summary Table

| Concept        | Key Point                                    |
| -------------- | -------------------------------------------- |
| Promise        | Handle async success/failure                 |
| Async/Await    | Synchronous-looking async code               |
| Microtasks     | `then()`, `await` — executed before timeouts |
| Macrotasks     | `setTimeout`, etc. — run after microtasks    |
| `Promise.all`  | All must succeed                             |
| `Promise.race` | First to settle                              |
| `Promise.any`  | First success                                |

---

Would you like **Set #8 on ES6 Features (Destructuring, Spread, Rest, Shorthand props, Modules)** next or something else like **closures**, **currying**, or **functional programming**?


### Set 8

Great choice, Vatan! 💪 Here's your **JavaScript Interview Set #8**, focusing on **ES6+ Features** — a common topic for mid to senior roles and often used in live coding rounds.

---

## 🌟 Set #8: ES6+ Features — Destructuring, Spread, Rest, Shorthand, Modules

---

### **Q71: What is Destructuring in JavaScript?**

✅ Extract values from arrays or objects into variables.

#### ✅ Object Destructuring:

```js
const user = { name: "Vatan", age: 37 };
const { name, age } = user;
console.log(name, age); // Vatan 37
```

#### ✅ Array Destructuring:

```js
const nums = [1, 2, 3];
const [a, b] = nums;
console.log(a, b); // 1 2
```

---

### **Q72: What is the Spread Operator (`...`) used for?**

✅ It spreads elements of an array or object.

#### ✅ Example - Arrays:

```js
const arr1 = [1, 2];
const arr2 = [...arr1, 3, 4];
console.log(arr2); // [1, 2, 3, 4]
```

#### ✅ Example - Objects:

```js
const obj1 = { a: 1 };
const obj2 = { ...obj1, b: 2 };
console.log(obj2); // { a: 1, b: 2 }
```

---

### **Q73: What is the Rest Operator (`...`) used for?**

✅ Gathers remaining values into an array or object.

```js
const [first, ...rest] = [10, 20, 30];
console.log(first); // 10
console.log(rest);  // [20, 30]
```

```js
const { a, ...others } = { a: 1, b: 2, c: 3 };
console.log(others); // { b: 2, c: 3 }
```

---

### **Q74: What is Object Property Shorthand?**

✅ If key and variable name are the same:

```js
const age = 37;
const person = { name: "Vatan", age };
console.log(person); // { name: 'Vatan', age: 37 }
```

---

### **Q75: Arrow Functions vs Regular Functions**

```js
const add = (a, b) => a + b;
console.log(add(2, 3)); // 5
```

✅ Differences:

* No own `this`, `arguments`
* Not suitable for constructors
* Shorter syntax

---

### **Q76: What are Template Literals?**

✅ Backtick syntax allows embedded variables using `${}`.

```js
const name = "Devpriyaa";
const greet = `Hello, ${name}!`;
console.log(greet); // Hello, Devpriyaa!
```

---

### **Q77: What is Default Parameter Value in JS?**

```js
function greet(name = "Guest") {
  console.log(`Hello, ${name}`);
}
greet(); // Hello, Guest
```

✅ Prevents `undefined` values for missing args.

---

### **Q78: What is Object Destructuring with Alias and Defaults?**

```js
const user = { id: 1, name: "Vatan" };
const { name: userName = "Unknown", age = 30 } = user;
console.log(userName, age); // Vatan 30
```

---

### **Q79: What are ES Modules (import/export)?**

✅ Modularize code across files.

#### 🔹 In `math.js`:

```js
export const add = (a, b) => a + b;
export default function subtract(a, b) {
  return a - b;
}
```

#### 🔹 In `main.js`:

```js
import subtract, { add } from './math.js';
console.log(add(1, 2));      // 3
console.log(subtract(5, 2)); // 3
```

---

### **Q80: What are Dynamic Imports?**

✅ Load modules at runtime using `import()`.

```js
async function loadMath() {
  const math = await import('./math.js');
  console.log(math.add(2, 3)); // 5
}
loadMath();
```

---

## 🧠 Summary Table

| Feature           | Syntax                         | Purpose                           |
| ----------------- | ------------------------------ | --------------------------------- |
| Destructuring     | `{a, b} = obj`, `[x, y] = arr` | Extract values                    |
| Spread `...`      | `[...arr]`, `{...obj}`         | Expand values                     |
| Rest `...`        | `(...args)`, `const {...rest}` | Gather remaining values           |
| Template Literals | `` `Hello ${name}` ``          | Multi-line strings, interpolation |
| Shorthand         | `{ name }`                     | Cleaner object creation           |
| Default Params    | `function(x = 1)`              | Default fallback values           |
| Modules           | `import/export`                | Code reuse across files           |

---

Would you like **Set #9 on Closures & Lexical Scope**, or should we shift to topics like **Memory Leaks**, **Event Delegation**, or **Browser APIs** next?


### Set 9

Great choice, Vatan! 💪 Here's your **JavaScript Interview Set #8**, focusing on **ES6+ Features** — a common topic for mid to senior roles and often used in live coding rounds.

---

## 🌟 Set #8: ES6+ Features — Destructuring, Spread, Rest, Shorthand, Modules

---

### **Q71: What is Destructuring in JavaScript?**

✅ Extract values from arrays or objects into variables.

#### ✅ Object Destructuring:

```js
const user = { name: "Vatan", age: 37 };
const { name, age } = user;
console.log(name, age); // Vatan 37
```

#### ✅ Array Destructuring:

```js
const nums = [1, 2, 3];
const [a, b] = nums;
console.log(a, b); // 1 2
```

---

### **Q72: What is the Spread Operator (`...`) used for?**

✅ It spreads elements of an array or object.

#### ✅ Example - Arrays:

```js
const arr1 = [1, 2];
const arr2 = [...arr1, 3, 4];
console.log(arr2); // [1, 2, 3, 4]
```

#### ✅ Example - Objects:

```js
const obj1 = { a: 1 };
const obj2 = { ...obj1, b: 2 };
console.log(obj2); // { a: 1, b: 2 }
```

---

### **Q73: What is the Rest Operator (`...`) used for?**

✅ Gathers remaining values into an array or object.

```js
const [first, ...rest] = [10, 20, 30];
console.log(first); // 10
console.log(rest);  // [20, 30]
```

```js
const { a, ...others } = { a: 1, b: 2, c: 3 };
console.log(others); // { b: 2, c: 3 }
```

---

### **Q74: What is Object Property Shorthand?**

✅ If key and variable name are the same:

```js
const age = 37;
const person = { name: "Vatan", age };
console.log(person); // { name: 'Vatan', age: 37 }
```

---

### **Q75: Arrow Functions vs Regular Functions**

```js
const add = (a, b) => a + b;
console.log(add(2, 3)); // 5
```

✅ Differences:

* No own `this`, `arguments`
* Not suitable for constructors
* Shorter syntax

---

### **Q76: What are Template Literals?**

✅ Backtick syntax allows embedded variables using `${}`.

```js
const name = "Devpriyaa";
const greet = `Hello, ${name}!`;
console.log(greet); // Hello, Devpriyaa!
```

---

### **Q77: What is Default Parameter Value in JS?**

```js
function greet(name = "Guest") {
  console.log(`Hello, ${name}`);
}
greet(); // Hello, Guest
```

✅ Prevents `undefined` values for missing args.

---

### **Q78: What is Object Destructuring with Alias and Defaults?**

```js
const user = { id: 1, name: "Vatan" };
const { name: userName = "Unknown", age = 30 } = user;
console.log(userName, age); // Vatan 30
```

---

### **Q79: What are ES Modules (import/export)?**

✅ Modularize code across files.

#### 🔹 In `math.js`:

```js
export const add = (a, b) => a + b;
export default function subtract(a, b) {
  return a - b;
}
```

#### 🔹 In `main.js`:

```js
import subtract, { add } from './math.js';
console.log(add(1, 2));      // 3
console.log(subtract(5, 2)); // 3
```

---

### **Q80: What are Dynamic Imports?**

✅ Load modules at runtime using `import()`.

```js
async function loadMath() {
  const math = await import('./math.js');
  console.log(math.add(2, 3)); // 5
}
loadMath();
```

---

## 🧠 Summary Table

| Feature           | Syntax                         | Purpose                           |
| ----------------- | ------------------------------ | --------------------------------- |
| Destructuring     | `{a, b} = obj`, `[x, y] = arr` | Extract values                    |
| Spread `...`      | `[...arr]`, `{...obj}`         | Expand values                     |
| Rest `...`        | `(...args)`, `const {...rest}` | Gather remaining values           |
| Template Literals | `` `Hello ${name}` ``          | Multi-line strings, interpolation |
| Shorthand         | `{ name }`                     | Cleaner object creation           |
| Default Params    | `function(x = 1)`              | Default fallback values           |
| Modules           | `import/export`                | Code reuse across files           |

---

Would you like **Set #9 on Closures & Lexical Scope**, or should we shift to topics like **Memory Leaks**, **Event Delegation**, or **Browser APIs** next?


### Set 9

Awesome, Vatan! Let’s dive into one of the most important and deeply asked JavaScript topics — **Closures, Lexical Scope, and Execution Context**. These are hot topics in interviews and are often tested via tricky MCQs and code snippets.

---

## 🌟 Set #9: Closures, Lexical Scope, and Execution Context

---

### **Q81: What is Lexical Scope in JavaScript?**

✅ Scope is determined by the physical placement of code.

```js
function outer() {
  let a = 10;
  function inner() {
    console.log(a); // 10 — inner has access to outer's scope
  }
  inner();
}
outer();
```

> 🔥 JS uses **lexical (static) scoping**, meaning a function's scope is based on **where** it was defined, not where it is called.

---

### **Q82: What is a Closure?**

✅ A closure is a function that remembers variables from its lexical scope even when the outer function has finished executing.

```js
function makeCounter() {
  let count = 0;
  return function () {
    count++;
    return count;
  };
}

const counter = makeCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

> 🔁 Even though `makeCounter` is finished, the inner function remembers `count`.

---

### **Q83: Where are Closures used in real life?**

* **Data encapsulation**
* **Function factories**
* **setTimeout loops**
* **React hooks (useState, useEffect)**

---

### **Q84: Common Closure Mistake with `var` in Loops**

```js
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Output: 3, 3, 3
```

✅ Fix with `let`:

```js
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Output: 0, 1, 2
```

> Because `let` is block-scoped and captures a new `i` per iteration.

---

### **Q85: Closure with `setTimeout` & IIFE**

```js
for (var i = 0; i < 3; i++) {
  (function (j) {
    setTimeout(() => console.log(j), 100);
  })(i);
}
// Output: 0, 1, 2
```

> 🔄 Classic use of closure with IIFE (Immediately Invoked Function Expression)

---

### **Q86: What is Execution Context in JS?**

✅ Environment where JS runs.

Three main phases:

1. **Creation Phase**: Variables and functions are hoisted.
2. **Execution Phase**: Code runs line by line.
3. **Destruction Phase**: Context is popped from call stack.

```js
function test() {
  let x = 10;
  function inner() {
    return x * 2;
  }
  return inner();
}
```

---

### **Q87: What is the Call Stack?**

✅ A stack that keeps track of function execution.

```js
function a() {
  b();
}
function b() {
  c();
}
function c() {
  console.log("Done");
}
a();
// Stack: c -> b -> a -> global
```

---

### **Q88: Can closures lead to memory leaks?**

✅ Yes, if not handled well. Especially with DOM or large references.

```js
function leaky() {
  let bigData = new Array(1000000).fill("*");
  return () => console.log(bigData.length);
}

const leak = leaky(); // `bigData` is retained
```

> ✅ Fix: Clear unused closures, avoid unintentional global access.

---

### **Q89: What are Function Factories using closures?**

```js
function multiplier(factor) {
  return function (number) {
    return number * factor;
  };
}

const double = multiplier(2);
console.log(double(5)); // 10
```

> ✅ Common in React patterns, currying, and reusable utility generators.

---

### **Q90: Private Variables using Closures**

```js
function secretBox() {
  let secret = "🗝️";
  return {
    getSecret: () => secret,
    setSecret: (val) => (secret = val),
  };
}

const box = secretBox();
console.log(box.getSecret()); // 🗝️
box.setSecret("🔒");
console.log(box.getSecret()); // 🔒
```

---

## 🧠 Summary Table

| Concept                 | Purpose                                    | Key Syntax / Note                      |
| ----------------------- | ------------------------------------------ | -------------------------------------- |
| Lexical Scope           | Scope is defined where function is written | Not where it's called                  |
| Closure                 | Inner function remembers outer variables   | `function outer() { return inner(); }` |
| Call Stack              | JS executes via LIFO stack                 | Last-in-first-out                      |
| IIFE                    | Executes immediately after definition      | `(function(){})()`                     |
| Memory Leak in Closures | Retaining large references unnecessarily   | Watch out in long-lived event handlers |

---

Would you like **Set #10: Promises, async/await, microtasks vs macrotasks**, or switch to **DOM event flow, bubbling/capturing, delegation**, or **OOP in JS (class, prototype, inheritance)?**


### Set 10

Awesome, Vatan! Let’s dive into one of the most important and deeply asked JavaScript topics — **Closures, Lexical Scope, and Execution Context**. These are hot topics in interviews and are often tested via tricky MCQs and code snippets.

---

## 🌟 Set #9: Closures, Lexical Scope, and Execution Context

---

### **Q81: What is Lexical Scope in JavaScript?**

✅ Scope is determined by the physical placement of code.

```js
function outer() {
  let a = 10;
  function inner() {
    console.log(a); // 10 — inner has access to outer's scope
  }
  inner();
}
outer();
```

> 🔥 JS uses **lexical (static) scoping**, meaning a function's scope is based on **where** it was defined, not where it is called.

---

### **Q82: What is a Closure?**

✅ A closure is a function that remembers variables from its lexical scope even when the outer function has finished executing.

```js
function makeCounter() {
  let count = 0;
  return function () {
    count++;
    return count;
  };
}

const counter = makeCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

> 🔁 Even though `makeCounter` is finished, the inner function remembers `count`.

---

### **Q83: Where are Closures used in real life?**

* **Data encapsulation**
* **Function factories**
* **setTimeout loops**
* **React hooks (useState, useEffect)**

---

### **Q84: Common Closure Mistake with `var` in Loops**

```js
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Output: 3, 3, 3
```

✅ Fix with `let`:

```js
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Output: 0, 1, 2
```

> Because `let` is block-scoped and captures a new `i` per iteration.

---

### **Q85: Closure with `setTimeout` & IIFE**

```js
for (var i = 0; i < 3; i++) {
  (function (j) {
    setTimeout(() => console.log(j), 100);
  })(i);
}
// Output: 0, 1, 2
```

> 🔄 Classic use of closure with IIFE (Immediately Invoked Function Expression)

---

### **Q86: What is Execution Context in JS?**

✅ Environment where JS runs.

Three main phases:

1. **Creation Phase**: Variables and functions are hoisted.
2. **Execution Phase**: Code runs line by line.
3. **Destruction Phase**: Context is popped from call stack.

```js
function test() {
  let x = 10;
  function inner() {
    return x * 2;
  }
  return inner();
}
```

---

### **Q87: What is the Call Stack?**

✅ A stack that keeps track of function execution.

```js
function a() {
  b();
}
function b() {
  c();
}
function c() {
  console.log("Done");
}
a();
// Stack: c -> b -> a -> global
```

---

### **Q88: Can closures lead to memory leaks?**

✅ Yes, if not handled well. Especially with DOM or large references.

```js
function leaky() {
  let bigData = new Array(1000000).fill("*");
  return () => console.log(bigData.length);
}

const leak = leaky(); // `bigData` is retained
```

> ✅ Fix: Clear unused closures, avoid unintentional global access.

---

### **Q89: What are Function Factories using closures?**

```js
function multiplier(factor) {
  return function (number) {
    return number * factor;
  };
}

const double = multiplier(2);
console.log(double(5)); // 10
```

> ✅ Common in React patterns, currying, and reusable utility generators.

---

### **Q90: Private Variables using Closures**

```js
function secretBox() {
  let secret = "🗝️";
  return {
    getSecret: () => secret,
    setSecret: (val) => (secret = val),
  };
}

const box = secretBox();
console.log(box.getSecret()); // 🗝️
box.setSecret("🔒");
console.log(box.getSecret()); // 🔒
```

---

## 🧠 Summary Table

| Concept                 | Purpose                                    | Key Syntax / Note                      |
| ----------------------- | ------------------------------------------ | -------------------------------------- |
| Lexical Scope           | Scope is defined where function is written | Not where it's called                  |
| Closure                 | Inner function remembers outer variables   | `function outer() { return inner(); }` |
| Call Stack              | JS executes via LIFO stack                 | Last-in-first-out                      |
| IIFE                    | Executes immediately after definition      | `(function(){})()`                     |
| Memory Leak in Closures | Retaining large references unnecessarily   | Watch out in long-lived event handlers |

---

Would you like **Set #10: Promises, async/await, microtasks vs macrotasks**, or switch to **DOM event flow, bubbling/capturing, delegation**, or **OOP in JS (class, prototype, inheritance)?**


### Set 10

Great choice, Vatan! Let’s now master **Set #10: Promises, async/await, microtask vs macrotask**, one of the most **frequently asked and misunderstood** JavaScript topics.

---

## 🌟 Set #10: Promises, `async/await`, Microtask vs Macrotask

---

### **Q91: What is a Promise in JavaScript?**

✅ A Promise represents the result of an **asynchronous operation**.

```js
const p = new Promise((resolve, reject) => {
  setTimeout(() => resolve("Success!"), 1000);
});

p.then(result => console.log(result)); // after 1s => Success!
```

> It has 3 states: **pending**, **fulfilled**, **rejected**

---

### **Q92: How does `then()` and `catch()` chaining work?**

```js
Promise.resolve(5)
  .then(num => num * 2)        // 10
  .then(num => {
    throw "Oops!";
  })
  .catch(err => console.log(err)); // Oops!
```

✅ Each `then` returns a new promise. If any `then` throws, control jumps to the nearest `catch`.

---

### **Q93: What is async/await?**

✅ `async/await` is syntax sugar over Promises that makes async code look synchronous.

```js
async function fetchData() {
  const res = await fetch("https://api.example.com/data");
  const data = await res.json();
  console.log(data);
}
```

> ❗ Await **pauses** execution within the async function until the Promise resolves.

---

### **Q94: Can we use `await` outside an `async` function?**

❌ No. It throws a syntax error (except in top-level await in modules).

```js
// SyntaxError: await is only valid in async functions
const data = await fetch(...);
```

✅ Fix:

```js
(async () => {
  const data = await fetch(...);
})();
```

---

### **Q95: async function always returns...?**

✅ A **Promise**, even if you return a plain value.

```js
async function sayHi() {
  return "Hello";
}
sayHi().then(console.log); // Hello
```

---

### **Q96: How to handle errors in async/await?**

```js
async function safeCall() {
  try {
    const res = await fetch("bad-url");
    const data = await res.json();
  } catch (err) {
    console.error("Error caught!", err);
  }
}
```

✅ `try...catch` handles async errors inside async functions.

---

### **Q97: What is the difference between Microtask and Macrotask queues?**

| Type          | Runs After   | Example                     |
| ------------- | ------------ | --------------------------- |
| **Microtask** | current task | `.then()`, `await`          |
| **Macrotask** | microtasks   | `setTimeout`, `setInterval` |

```js
console.log("1");

setTimeout(() => console.log("2"), 0);   // macrotask
Promise.resolve().then(() => console.log("3")); // microtask

console.log("4");
```

🧠 Output:
`1`, `4`, `3`, `2`

---

### **Q98: Promise.all vs Promise.race vs Promise.any vs Promise.allSettled**

```js
const p1 = Promise.resolve(1);
const p2 = Promise.reject("Error");
const p3 = new Promise(res => setTimeout(() => res(3), 100));

Promise.all([p1, p3])
  .then(console.log);       // [1, 3]

Promise.all([p1, p2])
  .catch(console.error);    // Error

Promise.any([p2, p3])
  .then(console.log);       // 3

Promise.race([p3, p1])
  .then(console.log);       // 1 (whichever resolves first)

Promise.allSettled([p1, p2])
  .then(console.log);
/* Output:
[
  { status: 'fulfilled', value: 1 },
  { status: 'rejected', reason: 'Error' }
]
*/
```

---

### **Q99: What is the event loop in JS?**

✅ It manages how the call stack, microtasks, and macrotasks execute.

![Event Loop Diagram](https://i.imgur.com/2yafO7T.png)
(Sample diagram if you'd like one visually in UI or app)

* Stack executes synchronous code
* Microtasks (`.then`, `await`) run **after current stack**, before macrotasks
* Macrotasks (`setTimeout`) run next

---

### **Q100: What will be the output?**

```js
console.log("A");

setTimeout(() => console.log("B"), 0);

Promise.resolve().then(() => console.log("C"));

console.log("D");
```

🧠 Output:

```
A
D
C
B
```

---

## 🧠 Summary Table

| Concept             | Key Point                       | Sample                       |
| ------------------- | ------------------------------- | ---------------------------- |
| Promise             | Async wrapper, 3 states         | `new Promise(...)`           |
| async/await         | Sugar for Promises              | `await fetch()`              |
| Micro vs Macro task | Micro runs first                | `.then()` vs `setTimeout()`  |
| Event loop          | Controls stack/task queue flow  | Important for output order   |
| Error handling      | use `.catch()` or `try...catch` | With both Promises and async |

---

Would you like **Set #11: JavaScript OOP (classes, inheritance, prototypes)** next, or something else like **DOM events**, **memory leaks**, or **array manipulation challenges**?


### Set 11

Awesome, Vatan! Let's dive into **Set #11: JavaScript OOP (Object-Oriented Programming)** — this covers **classes, inheritance, prototypes**, and other core interview topics.

---

## 🌟 Set #11: JavaScript OOP – Classes, Inheritance, Prototypes

---

### **Q101: What is a class in JavaScript?**

✅ A class is a **template** for creating objects.

```js
class Person {
  constructor(name) {
    this.name = name;
  }

  greet() {
    console.log(`Hi, I'm ${this.name}`);
  }
}

const p1 = new Person("Vatan");
p1.greet(); // Hi, I'm Vatan
```

---

### **Q102: What is the `constructor()` method?**

✅ It's a special method called **automatically** when a new object is created from the class.

```js
class Car {
  constructor(model) {
    this.model = model;
  }
}
const c = new Car("Tesla");
```

---

### **Q103: How does inheritance work using `extends`?**

✅ Child class can **inherit** properties/methods from a parent class using `extends`.

```js
class Animal {
  speak() {
    console.log("Animal speaks");
  }
}

class Dog extends Animal {
  speak() {
    super.speak(); // Animal speaks
    console.log("Dog barks");
  }
}

const d = new Dog();
d.speak();
```

---

### **Q104: What is `super()` used for?**

✅ `super()` calls the parent class’s constructor or method.

```js
class A {
  constructor(name) {
    this.name = name;
  }
}

class B extends A {
  constructor(name, age) {
    super(name);     // Calls A’s constructor
    this.age = age;
  }
}
```

---

### **Q105: What are prototypes in JavaScript?**

✅ Every object in JS has an internal link to another object called its **prototype**.

```js
function User(name) {
  this.name = name;
}

User.prototype.sayHi = function () {
  console.log(`Hi, ${this.name}`);
};

const u1 = new User("Vatan");
u1.sayHi(); // Hi, Vatan
```

---

### **Q106: What’s the difference between class methods and prototype methods?**

| Class Syntax     | Underlying Mechanism               |
| ---------------- | ---------------------------------- |
| `class` keyword  | Uses **prototypes** under the hood |
| Methods in class | Go to `ClassName.prototype`        |

✅ So this:

```js
class A {
  greet() {}
}
```

Is the same as:

```js
function A() {}
A.prototype.greet = function () {};
```

---

### **Q107: What is `Object.create()` used for?**

✅ Creates a new object with the given prototype.

```js
const animal = {
  speak() {
    console.log("generic sound");
  }
};

const dog = Object.create(animal);
dog.speak(); // generic sound
```

---

### **Q108: How can we implement private fields in a class?**

✅ Use `#` to declare private fields (ES2022+).

```js
class Bank {
  #balance = 1000;

  getBalance() {
    return this.#balance;
  }
}

const b = new Bank();
console.log(b.getBalance()); // 1000
// console.log(b.#balance); ❌ SyntaxError
```

---

### **Q109: How does method overriding work in classes?**

✅ Subclasses can override parent methods.

```js
class Parent {
  greet() {
    console.log("Parent");
  }
}
class Child extends Parent {
  greet() {
    console.log("Child");
  }
}

const obj = new Child();
obj.greet(); // Child
```

---

### **Q110: What is the prototype chain?**

✅ When accessing a property/method, JS looks up the prototype chain.

```js
const obj = {};
console.log(obj.toString); // inherited from Object.prototype
```

🧠 Chain:

```
obj → Object.prototype → null
```

---

## ✅ Summary Table

| Concept           | Purpose                             | Syntax / Example                     |
| ----------------- | ----------------------------------- | ------------------------------------ |
| `class`           | Blueprint for objects               | `class A {}`                         |
| `constructor()`   | Initializes object                  | `constructor(arg) { this.x = arg; }` |
| `extends`         | Inheritance                         | `class B extends A {}`               |
| `super()`         | Calls parent constructor or method  | `super()`                            |
| `prototype`       | Shared methods/properties           | `Function.prototype.method = fn`     |
| `Object.create()` | Create object with custom prototype | `Object.create(proto)`               |
| Private Fields    | Restrict access within class        | `#myPrivateVar`                      |

---

### Would you like **Set #12: Event Delegation, Bubbling, Capturing, and DOM tricks** next?

Or dive into something like **Closures, Currying, and Functional JS**?


### Set 12

Awesome, Vatan! Let's dive into **Set #11: JavaScript OOP (Object-Oriented Programming)** — this covers **classes, inheritance, prototypes**, and other core interview topics.

---

## 🌟 Set #11: JavaScript OOP – Classes, Inheritance, Prototypes

---

### **Q101: What is a class in JavaScript?**

✅ A class is a **template** for creating objects.

```js
class Person {
  constructor(name) {
    this.name = name;
  }

  greet() {
    console.log(`Hi, I'm ${this.name}`);
  }
}

const p1 = new Person("Vatan");
p1.greet(); // Hi, I'm Vatan
```

---

### **Q102: What is the `constructor()` method?**

✅ It's a special method called **automatically** when a new object is created from the class.

```js
class Car {
  constructor(model) {
    this.model = model;
  }
}
const c = new Car("Tesla");
```

---

### **Q103: How does inheritance work using `extends`?**

✅ Child class can **inherit** properties/methods from a parent class using `extends`.

```js
class Animal {
  speak() {
    console.log("Animal speaks");
  }
}

class Dog extends Animal {
  speak() {
    super.speak(); // Animal speaks
    console.log("Dog barks");
  }
}

const d = new Dog();
d.speak();
```

---

### **Q104: What is `super()` used for?**

✅ `super()` calls the parent class’s constructor or method.

```js
class A {
  constructor(name) {
    this.name = name;
  }
}

class B extends A {
  constructor(name, age) {
    super(name);     // Calls A’s constructor
    this.age = age;
  }
}
```

---

### **Q105: What are prototypes in JavaScript?**

✅ Every object in JS has an internal link to another object called its **prototype**.

```js
function User(name) {
  this.name = name;
}

User.prototype.sayHi = function () {
  console.log(`Hi, ${this.name}`);
};

const u1 = new User("Vatan");
u1.sayHi(); // Hi, Vatan
```

---

### **Q106: What’s the difference between class methods and prototype methods?**

| Class Syntax     | Underlying Mechanism               |
| ---------------- | ---------------------------------- |
| `class` keyword  | Uses **prototypes** under the hood |
| Methods in class | Go to `ClassName.prototype`        |

✅ So this:

```js
class A {
  greet() {}
}
```

Is the same as:

```js
function A() {}
A.prototype.greet = function () {};
```

---

### **Q107: What is `Object.create()` used for?**

✅ Creates a new object with the given prototype.

```js
const animal = {
  speak() {
    console.log("generic sound");
  }
};

const dog = Object.create(animal);
dog.speak(); // generic sound
```

---

### **Q108: How can we implement private fields in a class?**

✅ Use `#` to declare private fields (ES2022+).

```js
class Bank {
  #balance = 1000;

  getBalance() {
    return this.#balance;
  }
}

const b = new Bank();
console.log(b.getBalance()); // 1000
// console.log(b.#balance); ❌ SyntaxError
```

---

### **Q109: How does method overriding work in classes?**

✅ Subclasses can override parent methods.

```js
class Parent {
  greet() {
    console.log("Parent");
  }
}
class Child extends Parent {
  greet() {
    console.log("Child");
  }
}

const obj = new Child();
obj.greet(); // Child
```

---

### **Q110: What is the prototype chain?**

✅ When accessing a property/method, JS looks up the prototype chain.

```js
const obj = {};
console.log(obj.toString); // inherited from Object.prototype
```

🧠 Chain:

```
obj → Object.prototype → null
```

---

## ✅ Summary Table

| Concept           | Purpose                             | Syntax / Example                     |
| ----------------- | ----------------------------------- | ------------------------------------ |
| `class`           | Blueprint for objects               | `class A {}`                         |
| `constructor()`   | Initializes object                  | `constructor(arg) { this.x = arg; }` |
| `extends`         | Inheritance                         | `class B extends A {}`               |
| `super()`         | Calls parent constructor or method  | `super()`                            |
| `prototype`       | Shared methods/properties           | `Function.prototype.method = fn`     |
| `Object.create()` | Create object with custom prototype | `Object.create(proto)`               |
| Private Fields    | Restrict access within class        | `#myPrivateVar`                      |

---

### Would you like **Set #12: Event Delegation, Bubbling, Capturing, and DOM tricks** next?

Or dive into something like **Closures, Currying, and Functional JS**?










