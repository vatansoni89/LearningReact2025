### â“ **What are Microservices and how do they differ from Monoliths?**

---

### âœ… **Definition of Microservices:**

> **Microservices** is an architectural style where a software application is composed of **small, independent services** that communicate with each other via **APIs or messaging**.

Each service:

* Focuses on **a single business capability** (e.g., User Service, Order Service)
* Is **autonomous** (own code, data, and deployment)
* Can be developed, deployed, and scaled **independently**

---

### ğŸ§± **Definition of Monolith:**

> A **Monolith** is a traditional architecture where the **entire application** â€” UI, business logic, and data access â€” is packaged and deployed **as a single unit**.

---

### ğŸ†š **Key Differences:**

| Feature               | **Monolith**                     | **Microservices**                                   |
| --------------------- | -------------------------------- | --------------------------------------------------- |
| **Structure**         | Single large codebase            | Multiple small, focused services                    |
| **Deployment**        | One deployment for the whole app | Each service can be deployed independently          |
| **Scalability**       | Scales as a whole                | Scales service-wise (e.g., only scale OrderService) |
| **Technology stack**  | Generally one tech stack         | Each service can use its own stack (polyglot)       |
| **Data**              | Shared database                  | Each service owns its own database                  |
| **Resilience**        | A bug can crash the whole system | Failure in one service wonâ€™t crash others           |
| **Development speed** | Slower in large teams            | Faster with independent teams working in parallel   |
| **Startup time**      | Long startup time                | Fast startup and deployment per service             |
| **Testing**           | Easier for small apps            | Requires more integration and contract testing      |
| **Complexity**        | Lower initial complexity         | Higher complexity due to service communication      |

---

### ğŸ§  **Example Analogy:**

* ğŸ¢ **Monolith** = One big office building with everyone inside (tightly coupled)
* ğŸ˜ï¸ **Microservices** = A colony of small independent houses (loosely coupled)

---

### ğŸš€ **When to Use What:**

| Use Case                             | Choose...                  |
| ------------------------------------ | -------------------------- |
| Small team or startup                | Monolith (faster to build) |
| Large app with independent modules   | Microservices              |
| Need for scaling individual features | Microservices              |
| Rapid prototyping                    | Monolith                   |
| Cloud-native, distributed systems    | Microservices              |

---

### â“ **How do you decide microservice boundaries?**

---

### ğŸ§  **Problem Statement:**

In microservices, itâ€™s crucial to split a system into independent servicesâ€”but **where to draw the line**? If you split too early or incorrectly, youâ€™ll face complexity, duplication, and integration hell.

---

### âœ… **Principles to Decide Microservice Boundaries:**

#### 1. **Business Capabilities (Domain-Driven Design - DDD)**

> Break down services by **what the business does**, not technical layers.

* Example: `OrderService`, `PaymentService`, `InventoryService`
* Each one maps to a **bounded context** in DDD.

ğŸ§© Use tools like **Event Storming** or **Domain Modeling** to explore boundaries.

---

#### 2. **Bounded Context (from DDD)**

> Each microservice should manage a **bounded context**, where its **data, logic, and rules** make sense together.

* E.g., `Customer` in `Billing` context â‰  `Customer` in `Support` context
* Services own their **models and data schema**

---

#### 3. **High Cohesion, Low Coupling**

> Group things that **change together** into the same service.

* âœ… Keep related behaviors together: `Checkout` and `Payment` may belong together.
* âŒ Don't mix unrelated things like `Authentication` and `Inventory`.

---

#### 4. **Single Responsibility Principle (SRP)**

> One microservice = One clear responsibility

* A service should be easy to describe in one sentence:
  âœ… `"This handles user authentication."`
  âŒ `"This handles user, product, and payment stuff."`

---

#### 5. **Independent Deployability**

> A good boundary enables you to **deploy that service without changing others**.

* If changing service A always requires updating B and C, they might not be correctly separated.

---

#### 6. **Organizational Alignment**

> Align service boundaries with **team ownership** (Conwayâ€™s Law)

* A service should map to **a teamâ€™s responsibility**, enabling autonomy.

---

#### 7. **Scalability & Performance Needs**

> Separate services based on **performance profiles** or **scaling needs**.

* `ImageProcessingService` may need horizontal scaling unlike `UserProfileService`.

---

#### 8. **Security & Data Isolation**

> Keep **sensitive domains** isolated.

* `PaymentService` should be isolated from general app logic for security and compliance.

---

### âš ï¸ Common Mistakes to Avoid

* âŒ Splitting by technical layers (e.g., â€œFrontendServiceâ€, â€œBackendServiceâ€)
* âŒ Starting with too many microservices before understanding the domain
* âŒ Sharing a database across services
* âŒ Copy-pasting the same models across services

---

### ğŸ§ª Real-World Example:

Letâ€™s say youâ€™re building an **e-commerce platform**.
You might identify these boundaries:

| Service Name        | Business Capability             |
| ------------------- | ------------------------------- |
| UserService         | Handles user registration/login |
| ProductService      | Manages product catalog         |
| OrderService        | Takes and tracks orders         |
| PaymentService      | Handles payments and refunds    |
| NotificationService | Sends emails/SMS/push           |

Each of these:

* Has a **clear business function**
* Can be built and deployed independently
* Doesnâ€™t share direct DB access with others

---

### â“ What is Domain-Driven Design (DDD) and how does it apply to microservices?

---

### âœ… **Definition:**

> **Domain-Driven Design (DDD)** is a software design approach that focuses on modeling software around the **core business domain**, its **terminology**, and its **rules** â€” in close collaboration with domain experts.

Invented by **Eric Evans**, DDD helps in building **clean, modular, and maintainable systems** by aligning code structure with **real-world business problems**.

---

### ğŸ§  **DDD Core Concepts** (simplified for microservices)

| Concept                 | Meaning                                                                                               |
| ----------------------- | ----------------------------------------------------------------------------------------------------- |
| **Domain**              | Area of business knowledge (e.g., e-commerce, banking)                                                |
| **Entity**              | An object with an identity (e.g., `Order`, `User`)                                                    |
| **Value Object**        | An object without identity (e.g., `Address`, `Money`)                                                 |
| **Aggregate**           | A cluster of objects treated as a single unit (e.g., `Order` includes `LineItems`)                    |
| **Bounded Context**     | A logical boundary where a specific model applies (e.g., â€œOrderâ€ in Shipping â‰  â€œOrderâ€ in Accounting) |
| **Ubiquitous Language** | Shared language between devs and business (e.g., using terms like "PaymentCaptured")                  |

---

### ğŸš§ **How DDD Applies to Microservices:**

#### 1. **Bounded Context = Microservice Boundary**

Each microservice should handle **one bounded context**.

> E.g., `OrderService` only manages orders, with its own "Order" model, independent of "Order" in another service like `ShippingService`.

---

#### 2. **Autonomy in Design & Data**

DDD promotes **clear ownership** of logic and data.
Each microservice:

* Models its domain logic independently
* Owns its database (no shared schema)

---

#### 3. **Team Alignment**

DDD encourages **team structure around business capabilities**, which matches **microservice team ownership** (per **Conwayâ€™s Law**).

---

#### 4. **Anti-Corruption Layer (ACL)**

To protect one bounded context from being polluted by anotherâ€™s model, DDD suggests building an **ACL**â€”often a **translator or adapter**.

> E.g., `BillingService` talks to `OrderService` using a DTO, not directly with internal models.

---

#### 5. **Ubiquitous Language for Better APIs**

Using business language consistently across code and APIs helps teams build **meaningful, domain-focused services**.

> Instead of `/getAll`, you'd have `/getShippedOrders`, `/calculateInvoice`.

---

### ğŸ’¡ Real-Life Analogy:

Imagine a **university**:

* Admin staff, professors, and hostel wardens each have a **different "student" model**
* DDD says: let each department (bounded context) manage its own view of "student" â€” and if they need to collaborate, use translators (ACL)

---

### ğŸ§© Example in Microservices (E-Commerce):

| Microservice      | Bounded Context | Key Entities                |
| ----------------- | --------------- | --------------------------- |
| `UserService`     | Identity        | `User`, `Role`, `Profile`   |
| `OrderService`    | Ordering        | `Order`, `LineItem`, `Cart` |
| `PaymentService`  | Billing         | `Payment`, `Invoice`        |
| `ShippingService` | Logistics       | `Shipment`, `Address`       |

Each one is modeled based on **its own rules**, data, and logic.

---

### âš ï¸ When NOT to go full DDD:

* Very small projects or MVPs
* Teams unfamiliar with the domain
* When overengineering outweighs benefit

---

Great! Letâ€™s walk through a Domain-Driven Design (DDD) example in C# that reflects:

> **"Admin staff, professors, and hostel wardens each have a different 'student' model"**
> â€” and we use an **Anti-Corruption Layer (ACL)** to collaborate between them.

---

## ğŸ« Real-Life Scenario: University

Each department is a **bounded context**:

* ğŸ“‘ **Admin Context** â€“ cares about `StudentId`, `AdmissionDate`, `FeeStatus`
* ğŸ“ **Academic Context** â€“ cares about `StudentId`, `Subjects`, `Grades`
* ğŸ›ï¸ **Hostel Context** â€“ cares about `StudentId`, `RoomNumber`, `StayHistory`

Each context models **Student** differently â€” this is DDD.

---

### ğŸ¯ Goal:

* Keep each context's model **independent**
* Use an **Anti-Corruption Layer (ACL)** to translate between models when they need to talk

---

## ğŸ§ª Step-by-Step C# Example

---

### 1ï¸âƒ£ **Admin Context â€“ AdminStudent.cs**

```csharp
namespace AdminContext.Models
{
    public class AdminStudent
    {
        public string StudentId { get; set; }
        public DateTime AdmissionDate { get; set; }
        public bool IsFeePaid { get; set; }
    }
}
```

---

### 2ï¸âƒ£ **Academic Context â€“ AcademicStudent.cs**

```csharp
namespace AcademicContext.Models
{
    public class AcademicStudent
    {
        public string StudentId { get; set; }
        public List<string> Subjects { get; set; }
        public Dictionary<string, string> Grades { get; set; }
    }
}
```

---

### 3ï¸âƒ£ **Hostel Context â€“ HostelStudent.cs**

```csharp
namespace HostelContext.Models
{
    public class HostelStudent
    {
        public string StudentId { get; set; }
        public string RoomNumber { get; set; }
        public List<DateTime> StayHistory { get; set; }
    }
}
```

---

## ğŸ”„ 4ï¸âƒ£ **Anti-Corruption Layer (ACL)**

Let's say Hostel wants to *know fee status* from Admin.

We **donâ€™t use AdminStudent directly in HostelContext** â€” instead, we define a **DTO** + **Adapter**.

---

### ğŸ“¦ ACL DTO for Hostel â†’ Admin call

```csharp
namespace HostelContext.ACL
{
    public class AdminStudentFeeDto
    {
        public string StudentId { get; set; }
        public bool IsFeePaid { get; set; }
    }
}
```

---

### ğŸ§  Adapter to fetch Admin data via ACL

```csharp
using HostelContext.ACL;
using AdminContext.Models;

namespace HostelContext.ACL
{
    public interface IAdminStudentService
    {
        AdminStudentFeeDto GetFeeStatus(string studentId);
    }

    public class AdminStudentServiceAdapter : IAdminStudentService
    {
        // Simulated Admin repository (in real case, use HTTP/gRPC etc.)
        private readonly List<AdminStudent> _adminDb;

        public AdminStudentServiceAdapter(List<AdminStudent> adminDb)
        {
            _adminDb = adminDb;
        }

        public AdminStudentFeeDto GetFeeStatus(string studentId)
        {
            var adminStudent = _adminDb.FirstOrDefault(s => s.StudentId == studentId);
            if (adminStudent == null) return null;

            return new AdminStudentFeeDto
            {
                StudentId = adminStudent.StudentId,
                IsFeePaid = adminStudent.IsFeePaid
            };
        }
    }
}
```

---

### ğŸ  Hostel Context Using ACL

```csharp
using HostelContext.Models;
using HostelContext.ACL;

public class HostelService
{
    private readonly IAdminStudentService _adminStudentService;

    public HostelService(IAdminStudentService adminStudentService)
    {
        _adminStudentService = adminStudentService;
    }

    public void AllocateRoomIfFeePaid(string studentId)
    {
        var feeStatus = _adminStudentService.GetFeeStatus(studentId);
        if (feeStatus?.IsFeePaid == true)
        {
            Console.WriteLine($"âœ… Room allocated to student {studentId}");
        }
        else
        {
            Console.WriteLine($"âŒ Cannot allocate room. Fees not paid by {studentId}");
        }
    }
}
```

---

## âœ… Benefits of This Approach

| Feature                       | How DDD handles it                 |
| ----------------------------- | ---------------------------------- |
| Context-specific student view | Each service has its own model     |
| Loose coupling                | No direct access to othersâ€™ models |
| Data ownership                | Each service owns its data         |
| Collaboration                 | Via ACL, not shared models         |
| Replaceable implementations   | You can mock/swap AdminService     |

---

## ğŸ§  Summary

* Each domain owns its **own model** of "Student"
* **No shared class**, **no shared database**, and **no forced schema**
* Collaboration happens through **ACL**, using DTOs and adapters
* This keeps your **microservices modular, testable, and maintainable**

---

### â“ **4. What is the role of a Service Registry in Microservices?**

---

### âœ… **Problem Statement**

In a microservices architecture, services are dynamic. They:

* Scale up/down (creating/destroying instances)
* Get deployed on different hosts/containers (IP/port changes)
* Need to find each other **without hardcoded addresses**

So, how does `Service A` **discover** where `Service B` is currently running?

---

### ğŸ§© **Solution: Service Registry**

A **Service Registry** is like a **phone book for microservices**.

---

### ğŸ“˜ **Definition**

> A **Service Registry** is a centralized directory where microservices **register themselves** (on startup) and **discover others** (when they need to call them).

---

### ğŸ—ï¸ **Key Responsibilities**

| Responsibility           | Example                                                                        |
| ------------------------ | ------------------------------------------------------------------------------ |
| **Service Registration** | Service B registers with: `ServiceName = B, URL = 10.0.0.5:5000`               |
| **Service Discovery**    | Service A asks: *"Where is B?"* â†’ gets URL from registry                       |
| **Health Checking**      | Registry pings services to remove unhealthy instances                          |
| **Load Balancing**       | Registry can return a **list of healthy instances** so client can load balance |

---

### ğŸ” **Interaction Diagram**

```
+------------+      (Register)     +--------------------+
| Service B  |  -----------------> |   Service Registry |
+------------+                    +--------------------+

+------------+   (Discover B)     +--------------------+
| Service A  |  ----------------->|   Service Registry |
+------------+                    +--------------------+
                                     |
                                     v
                           Returns: B at 10.0.0.5:5000
```

---

### ğŸ› ï¸ **.NET Core & Azure Usage**

| Platform       | Service Registry Option                     |
| -------------- | ------------------------------------------- |
| **.NET Core**  | Steeltoe + Eureka, Consul, ZooKeeper        |
| **Azure**      | Azure Service Fabric, Azure API Management  |
| **Kubernetes** | Built-in service discovery via DNS + labels |

---

### ğŸ—ƒï¸ **Example Tools**

* **Eureka (Netflix OSS)** â€“ Java ecosystem (used with Steeltoe in .NET)
* **Consul (HashiCorp)** â€“ Popular, language-agnostic
* **etcd** â€“ Often used by Kubernetes
* **Azure Service Fabric Naming Service** â€“ Microsoft native

---

### ğŸ’¡ Real-World Analogy

> You donâ€™t memorize everyoneâ€™s phone number. You check your **contacts app** or **Truecaller** â€” thatâ€™s your **Service Registry** for humans.

---

Great question, Vatan! Letâ€™s walk through **how service registry and discovery works in AKS (Azure Kubernetes Service)** â€” because in Kubernetes (including AKS), **you donâ€™t need a separate service registry tool like Consul or Eureka**.

---

## âœ… **How Service Discovery Works in AKS (Kubernetes)**

---

### ğŸš§ Problem:

In microservices, how does one pod (say, `orderservice`) find another pod (`inventoryservice`) **without knowing its IP address**, which keeps changing?

---

### âœ… **Kubernetes Built-in Solution: DNS-based Service Discovery**

Kubernetes (including AKS) has a **built-in DNS system** + internal load balancing.

---

### ğŸ§  How it works (step-by-step):

1. **You deploy a microservice (as a pod)**
   Example: `orderservice` pod running on some random node.

2. **You expose it with a Service object**

   ```yaml
   apiVersion: v1
   kind: Service
   metadata:
     name: orderservice
   spec:
     selector:
       app: orderservice
     ports:
       - port: 80
         targetPort: 8080
   ```

   This creates a **stable name**: `orderservice.default.svc.cluster.local`

3. **Kube-DNS automatically registers the service name**

   * You can now ping/call `http://orderservice` from any other pod in the same namespace
   * Kubernetes DNS resolves this to the internal cluster IP (via kube-proxy and iptables)

4. **Service Load Balancer spreads traffic among pods**
   If `orderservice` has 3 replicas, the request is distributed internally.

---

### ğŸ’¡ Diagram

```
+----------------------+        +---------------------+
|  Pod A: Inventory    | -----> |  Service: orderservice |
+----------------------+        +---------------------+
                                       |
                        DNS: orderservice.default.svc.cluster.local
                                       |
                        Load Balancer â†’ Pod: OrderService 1
                                        â†’ Pod: OrderService 2
```

---

### ğŸ—ï¸ DNS Names Format in AKS:

| DNS Format                                | Example                                  |
| ----------------------------------------- | ---------------------------------------- |
| `<service>`                               | `orderservice`                           |
| `<service>.<namespace>`                   | `orderservice.default`                   |
| `<service>.<namespace>.svc.cluster.local` | `orderservice.default.svc.cluster.local` |

---

### ğŸš€ Bonus Features of AKS Discovery:

| Feature         | How it works in AKS                              |
| --------------- | ------------------------------------------------ |
| Health checks   | Use `readinessProbe` and `livenessProbe` in pods |
| Auto-scaling    | `HorizontalPodAutoscaler` adjusts replicas       |
| Load Balancing  | Built into the `Service` object                  |
| External access | Use `Ingress` or `LoadBalancer` type service     |

---

### ğŸ§ª Example

#### 1. Call service from another microservice

```csharp
var client = new HttpClient();
var result = await client.GetAsync("http://orderservice/api/orders");
```

#### 2. Service discovery resolves `orderservice` via AKS DNS

---

### ğŸ” Secure Discovery (Optional)

Use:

* **TLS with Ingress Controller**
* **Azure Private DNS** for cross-cluster resolution
* **Service Mesh** like **Istio or Linkerd** for secure mTLS discovery

---

### ğŸ’¬ Summary:

| Concept            | In AKS/Kubernetes                    |
| ------------------ | ------------------------------------ |
| Service Registry   | Built-in DNS + `Service` objects     |
| Load Balancer      | Kube-proxy + ClusterIP               |
| Health Monitoring  | Probes in Pod specs                  |
| Dynamic Resolution | DNS handles IP changes automatically |
| Service Discovery  | DNS-based (`http://servicename`)     |

---

### â“ 5. **How do you implement inter-service communication in microservices?**

---

### âœ… **Problem Statement**

In a microservices architecture:

* Services are distributed
* Each has its own DB and domain logic
  So, how do they **talk to each other**?

---

## ğŸ”„ Two Types of Inter-Service Communication

| Mode                | Example Use Case                            | Tech Examples                                       |
| ------------------- | ------------------------------------------- | --------------------------------------------------- |
| ğŸ”¹ **Synchronous**  | Get real-time data (e.g., get user profile) | REST, gRPC, HTTP APIs                               |
| ğŸ”¸ **Asynchronous** | Notify about events (e.g., order placed)    | Message queues (Azure Service Bus, RabbitMQ, Kafka) |

---

## ğŸ”¹ 1. **Synchronous Communication**

#### âœ… Use when:

* Real-time response is required
* Calling service **canâ€™t proceed** without the result

#### ğŸ“¦ Technologies:

* **REST API over HTTP** (most common)
* **gRPC** (faster, strongly typed, ideal for internal services)

#### ğŸ”§ Example: .NET Core REST client

```csharp
public class UserClientService
{
    private readonly HttpClient _client;

    public UserClientService(HttpClient client)
    {
        _client = client;
    }

    public async Task<UserDto> GetUserAsync(Guid id)
    {
        var response = await _client.GetAsync($"/api/users/{id}");
        response.EnsureSuccessStatusCode();
        return await response.Content.ReadFromJsonAsync<UserDto>();
    }
}
```

> In AKS: You can call the service using its Kubernetes DNS name, e.g., `http://userservice`.

---

## ğŸ”¸ 2. **Asynchronous Communication**

#### âœ… Use when:

* The result can come **later**
* Improves **decoupling**, **scalability**, and **resilience**

#### ğŸ“¦ Technologies:

* **Azure Service Bus**
* **RabbitMQ**
* **Apache Kafka**
* **MassTransit** (abstraction over queues in .NET)

#### ğŸ”§ Example: Azure Service Bus (with MassTransit)

âœ… *Publisher sends event*:

```csharp
await _bus.Publish(new OrderPlaced
{
    OrderId = Guid.NewGuid(),
    Amount = 1000,
    UserId = userId
});
```

âœ… *Subscriber handles it*:

```csharp
public class OrderPlacedConsumer : IConsumer<OrderPlaced>
{
    public Task Consume(ConsumeContext<OrderPlaced> context)
    {
        var data = context.Message;
        Console.WriteLine($"Received Order: {data.OrderId}, Amount: {data.Amount}");
        return Task.CompletedTask;
    }
}
```

---

## ğŸ”€ Hybrid Pattern

In real-world projects:

* Use **REST for queries** (request-response)
* Use **Messages for commands/events** (fire-and-forget or pub-sub)

---

## ğŸ” Security & Resilience Tips

| Aspect         | What to use                                             |
| -------------- | ------------------------------------------------------- |
| Authentication | OAuth2 / JWT between services                           |
| Resilience     | Retry, Circuit Breaker (with Polly in .NET)             |
| Load Balancing | Kubernetes service + ingress                            |
| Observability  | Distributed tracing (OpenTelemetry, Azure App Insights) |

---

## ğŸ” Summary

| Communication Type | Protocol    | Pattern          | Example Use Case            |
| ------------------ | ----------- | ---------------- | --------------------------- |
| Synchronous        | HTTP, gRPC  | Request-Response | Get profile, validate token |
| Asynchronous       | Service Bus | Pub/Sub, Queue   | Order placed, email sent    |

---

Hereâ€™s a crystal-clear breakdown of the difference between **synchronous** and **asynchronous communication** in microservices â€” with examples relevant to .NET and Azure:

---

### ğŸ§  **6. Difference Between Synchronous and Asynchronous Communication**

| Feature                     | ğŸ§­ **Synchronous Communication**                        | ğŸ•Šï¸ **Asynchronous Communication**                       |
| --------------------------- | ------------------------------------------------------- | -------------------------------------------------------- |
| **Definition**              | Request & wait for response (real-time)                 | Send message & continue (no need to wait)                |
| **Timing**                  | Blocking â€” both services must be available at same time | Non-blocking â€” sender continues even if receiver is down |
| **Typical Protocols**       | HTTP, HTTPS, gRPC                                       | Message Queues (Azure Service Bus, Kafka, RabbitMQ)      |
| **Use Case**                | Fetch user data, get order status                       | Send email, process payment, log audit                   |
| **Tight Coupling**          | More tightly coupled (availability dependency)          | Loosely coupled (decouples services)                     |
| **Retries/Resilience**      | Needs retry logic, circuit breakers                     | Message broker handles retry and durability              |
| **Speed of Processing**     | Faster for immediate response needed                    | Better for background or bulk operations                 |
| **Observability/Debugging** | Easier to trace (single call chain)                     | Harder â€” needs tracing correlation (ActivityId, etc.)    |
| **Examples in .NET Core**   | `HttpClient`, `gRPC`                                    | `MassTransit`, `Azure.Messaging.ServiceBus`              |

---

### ğŸ”§ .NET Examples:

#### âœ… **Synchronous (HTTP REST Call)**

```csharp
var response = await _httpClient.GetAsync("http://userservice/api/users/1");
var user = await response.Content.ReadFromJsonAsync<UserDto>();
```

#### âœ… **Asynchronous (Azure Service Bus with MassTransit)**

```csharp
await _bus.Publish(new OrderPlaced { OrderId = Guid.NewGuid() });
```

---

### ğŸš´ Real-Life Analogy:

| Type             | Analogy                                    |
| ---------------- | ------------------------------------------ |
| **Synchronous**  | Call your friend and wait till they answer |
| **Asynchronous** | Send them a WhatsApp message and move on   |

---

### ğŸ“Œ Summary Table

| Aspect                 | Synchronous                  | Asynchronous                      |
| ---------------------- | ---------------------------- | --------------------------------- |
| Blocking?              | âœ… Yes                        | âŒ No                              |
| Needs Immediate Reply? | âœ… Yes                        | âŒ No                              |
| Example in .NET        | `HttpClient`, `gRPC`         | `MassTransit`, `ServiceBusClient` |
| Azure Example          | Azure App Gateway + HTTP     | Azure Service Bus                 |
| Resilience             | Needs Polly, Circuit Breaker | Queue ensures delivery            |

---

### â“ 8. **What Are the Best Practices for Designing Microservice APIs?**

Designing APIs for microservices is not just about creating endpoints â€” it's about making them **clear, scalable, secure, and future-proof**. Here's how you do it like a pro in .NET Core and Azure:

---

### âœ… 1. **Design for a Bounded Context**

ğŸ§  Each microservice should expose **only the functionality relevant to its domain**.

**Example:**

* `UserService` â€“ manages user info (not orders!)
* `OrderService` â€“ handles orders, not users

ğŸ§± Keep API surface area **small and focused**.

---

### âœ… 2. **Use REST or gRPC Based on Need**

| Type | When to Use                      | Tech in .NET               |
| ---- | -------------------------------- | -------------------------- |
| REST | Public APIs, browser-friendly    | `Controller`, `HttpClient` |
| gRPC | Internal, high-performance comms | `Grpc.AspNetCore`          |

ğŸ’¡ For internal service-to-service calls: prefer **gRPC** (binary, efficient)

---

### âœ… 3. **Version Your APIs**

Never break existing clients. Use **URL-based versioning** or **header versioning**.

```http
GET /api/v1/products
```

```csharp
[Route("api/v1/[controller]")]
```

#### Implementation

Here's a full example showing **API versioning in .NET Core** using **URL-based versioning** (`/api/v1/products`) along with tips for **safe deployment to AKS** without affecting existing clients.

---

## âœ… Step-by-Step Code Sample: URL-Based API Versioning in .NET Core

### ğŸ¯ Scenario:

You're building a `ProductsController` with `v1` and `v2` versions. `v2` adds a new field (`Category`).

---

### ğŸ“ 1. **Install Package**

Install the versioning NuGet package:

```bash
dotnet add package Microsoft.AspNetCore.Mvc.Versioning
```

---

### ğŸ› ï¸ 2. **Startup.cs / Program.cs Configuration**

```csharp
builder.Services.AddApiVersioning(options =>
{
    options.ReportApiVersions = true; // Adds headers like: api-supported-versions
    options.AssumeDefaultVersionWhenUnspecified = true;
    options.DefaultApiVersion = new ApiVersion(1, 0);
    options.ApiVersionReader = new UrlSegmentApiVersionReader(); // Enables /v{version}
});
```

---

### ğŸ“¦ 3. **ProductsController v1**

```csharp
using Microsoft.AspNetCore.Mvc;

namespace MyApp.Controllers.v1;

[ApiController]
[ApiVersion("1.0")]
[Route("api/v{version:apiVersion}/[controller]")]
public class ProductsController : ControllerBase
{
    [HttpGet]
    public IActionResult Get()
    {
        return Ok(new[]
        {
            new { Id = 1, Name = "Laptop", Price = 50000 }
        });
    }
}
```

---

### ğŸ“¦ 4. **ProductsController v2**

```csharp
using Microsoft.AspNetCore.Mvc;

namespace MyApp.Controllers.v2;

[ApiController]
[ApiVersion("2.0")]
[Route("api/v{version:apiVersion}/[controller]")]
public class ProductsController : ControllerBase
{
    [HttpGet]
    public IActionResult Get()
    {
        return Ok(new[]
        {
            new { Id = 1, Name = "Laptop", Price = 50000, Category = "Electronics" }
        });
    }
}
```

---

### âœ… Testing Your Versions:

| Request URL        | Version |
| ------------------ | ------- |
| `/api/v1/products` | v1      |
| `/api/v2/products` | v2      |

---

## ğŸš€ Deploying to AKS Without Breaking Clients

### ğŸ§© 1. **Kubernetes Readiness**

When deploying new versions:

* Create **side-by-side deployments** with the new version of the API.
* Use **labels/selectors** to route traffic if needed.
* If youâ€™re using **Azure API Management** or **Ingress (like NGINX)**, route `/api/v1` and `/api/v2` as required.

---

### ğŸ§ª 2. **Test Before Cutting Over**

Use `readinessProbes` and `livenessProbes` to **ensure the new pods are ready** before traffic is routed to them:

```yaml
readinessProbe:
  httpGet:
    path: /api/v2/products
    port: 80
  initialDelaySeconds: 5
  periodSeconds: 10
```

---

### âš™ï¸ 3. **Azure DevOps or Helm Deployment Tip**

* Use **blue-green deployment** or **canary rollout** with Helm or `kubectl rollout` to avoid downtime.
* Make sure **existing URLs (v1)** are untouched when pushing the new version.

---

### ğŸ“Œ Summary

| Step                   | Key Action                                              |
| ---------------------- | ------------------------------------------------------- |
| Controller Routing     | Use `[Route("api/v{version:apiVersion}/[controller]")]` |
| Versioning Config      | Use `AddApiVersioning()` with URL segment               |
| Deploying in AKS       | Use readiness probes, side-by-side deployment           |
| API Gateway (optional) | Route based on version                                  |

---

Would you like a working GitHub sample or Helm chart setup for deploying these APIs in AKS with zero downtime?

---

### âœ… 4. **Follow HTTP Semantics Properly**

| HTTP Verb | Action         | Example           |
| --------- | -------------- | ----------------- |
| GET       | Read           | `/api/products/1` |
| POST      | Create         | `/api/products`   |
| PUT       | Update entire  | `/api/products/1` |
| PATCH     | Update partial | `/api/products/1` |
| DELETE    | Remove         | `/api/products/1` |

ğŸ” Avoid side effects on `GET`.

---

### âœ… 5. **Use Resource-Oriented URLs**

âŒ Bad: `/doUpdateProduct?id=5`

âœ… Good: `/api/products/5`

---

### âœ… 6. **Consistent Error Handling (Problem Details)**

Use **RFC 7807** format for API errors.

```json
{
  "type": "https://example.com/errors/validation",
  "title": "Validation Failed",
  "status": 400,
  "errors": {
    "price": ["Price must be > 0"]
  }
}
```

In .NET Core:

```csharp
services.AddProblemDetails();
```

---

### âœ… 7. **HATEOAS (Optional)**

Provide links for discoverability:

```json
{
  "productId": 1,
  "name": "Laptop",
  "_links": {
    "self": "/api/products/1",
    "update": "/api/products/1",
    "delete": "/api/products/1"
  }
}
```

---

### âœ… 8. **Secure Your APIs**

ğŸ” Use:

* **OAuth2 / OpenID Connect** via Azure AD or IdentityServer
* **JWT Tokens**
* **Rate limiting**
* **CORS policy** per service

```csharp
services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(...);
```

---

### âœ… 9. **Use API Gateways (e.g., YARP or Azure API Management)**

Route, authenticate, and throttle traffic centrally.

âœ… Benefits:

* Aggregates responses
* Enforces policies
* Offloads auth concerns

---

### âœ… 10. **Use OpenAPI/Swagger for Documentation**

```csharp
services.AddSwaggerGen();
```

* Auto-generates documentation
* Helps other teams and tools (e.g., Postman)

---

### ğŸš€ Bonus Tips

* ğŸ“¦ Use **DTOs** to separate API models from domain models
* â±ï¸ Set **timeouts** and **circuit breakers** on consuming services
* ğŸ“Š Log and trace every API call with **correlation IDs**

---

### ğŸ¯ Summary Table

| Practice                | Why It Matters                           |
| ----------------------- | ---------------------------------------- |
| Bounded Context         | Separation of concerns                   |
| Versioning              | Safe changes over time                   |
| Correct HTTP verbs      | Standardization and clarity              |
| Clean resource URLs     | Better RESTfulness                       |
| Consistent error format | Easier debugging                         |
| Security (OAuth/JWT)    | Secure access                            |
| API Gateway             | Cross-cutting concerns managed centrally |
| Swagger docs            | Developer experience                     |

---

### âŒ 11. What are **Anti-Patterns to Avoid** in Microservice Design?

Anti-patterns are bad practices that can lead to complexity, poor performance, or failure in microservices architecture. Letâ€™s break them down with explanations and fun nicknames to remember.

---

### ğŸ’£ Common Microservice Anti-Patterns

| ğŸ”¢ | ğŸ§¨ **Anti-Pattern**                     | âš ï¸ **Why Itâ€™s Bad**                                                                 |
| -- | --------------------------------------- | ----------------------------------------------------------------------------------- |
| 1  | **Distributed Monolith**                | Services are deployed separately but tightly coupled â€” defeats the purpose.         |
| 2  | **Too Many Microservices**              | Over-splitting increases complexity and slows development.                          |
| 3  | **Shared Database**                     | Services depending on the same DB violate autonomy and cause coupling.              |
| 4  | **God Gateway**                         | API Gateway doing too much (auth, logic, routing, validation, transformation, etc.) |
| 5  | **Inconsistent Data Models**            | No governance = chaos when services represent entities differently.                 |
| 6  | **Chatty Services**                     | Excessive synchronous calls between services â€” leads to latency and failures.       |
| 7  | **Ignoring Observability**              | No logs, metrics, or tracing = impossible to debug issues.                          |
| 8  | **Lack of Versioning**                  | Breaking changes in APIs crash consumers.                                           |
| 9  | **Tight Coupling via Shared Libraries** | Sharing internal logic/libraries couples services at build time.                    |
| 10 | **No Consumer-Driven Contracts**        | Leads to misaligned expectations and runtime errors.                                |
| 11 | **One Big Team on All Services**        | Team boundaries should align with service boundaries.                               |

---

### ğŸ§  Remember with Mnemonic:

**"Distributed Gods Split Chatty Databases, Leaving Logs Lost."**

---

### âœ… Best Practices Instead

| Anti-Pattern    | Replace with                                   |
| --------------- | ---------------------------------------------- |
| Shared DB       | Database-per-service with APIs or events       |
| Chatty services | Async/event-driven design, aggregate responses |
| God Gateway     | Thin gateway + logic within services           |
| No versioning   | Versioned APIs with backward compatibility     |
| One big team    | Cross-functional, service-aligned teams        |

---

### ğŸ§ª Bonus Real-World Examples

* âŒ `OrderService` directly queries `CustomerService`â€™s database â†’ **Shared DB**
* âŒ `AuthService`, `BillingService`, `ShippingService` all call each other synchronously â†’ **Chatty Services**
* âŒ Updating a shared NuGet package breaks all services â†’ **Shared Libraries Coupling**

---

### ğŸ’ª 12. How Do You Ensure **Resilience** in Microservices?

---

> ğŸ§  **Resilience** means your microservices **keep working** (or fail gracefully) even when things go wrong â€” like timeouts, crashes, or downstream service failures.

---

### ğŸ”§ Key Patterns & Techniques for Resilience

| #  | ğŸ’¡ **Technique**         | ğŸ› ï¸ **What It Does**                                                     |
| -- | ------------------------ | ------------------------------------------------------------------------ |
| 1  | **Retry**                | Re-attempt failed calls (with delay/backoff)                             |
| 2  | **Circuit Breaker**      | Stop calling a failing service temporarily to prevent overload           |
| 3  | **Timeouts**             | Set limits on how long a service waits before giving up                  |
| 4  | **Bulkhead Isolation**   | Limit resource usage per service to contain failure                      |
| 5  | **Fallbacks**            | Provide an alternative response when a call fails                        |
| 6  | **Rate Limiting**        | Prevent overloading a service by limiting the number of calls            |
| 7  | **Caching**              | Store previous responses to avoid unnecessary calls during downtime      |
| 8  | **Health Checks**        | Detect when services are down and stop routing traffic to them           |
| 9  | **Graceful Degradation** | Offer reduced functionality instead of complete failure                  |
| 10 | **Idempotency**          | Ensure repeated operations (like retries) donâ€™t cause unintended effects |

---

### ğŸ§ª Example in .NET Core Using **Polly**

```csharp
// In Startup.cs or Program.cs with HttpClientFactory
services.AddHttpClient<IProductService, ProductService>()
    .AddTransientHttpErrorPolicy(policy =>
        policy.WaitAndRetryAsync(3, retryAttempt =>
            TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) // exponential backoff
        )
    )
    .AddTransientHttpErrorPolicy(policy =>
        policy.CircuitBreakerAsync(5, TimeSpan.FromSeconds(30)) // Circuit Breaker
    );
```

---

### ğŸ§± In AKS / Kubernetes

| Feature                   | How It Helps                          |
| ------------------------- | ------------------------------------- |
| `livenessProbe`           | Restart a container if it's unhealthy |
| `readinessProbe`          | Donâ€™t send traffic until ready        |
| Horizontal Pod Autoscaler | Adds more instances on high load      |
| Istio / Linkerd           | Built-in retries, circuit breakers    |

---

### ğŸ¤– Real-World Example

Your `OrderService` calls `PaymentService`. If `PaymentService` is down:

* Retry it once or twice
* If still failing, break the circuit
* Return a fallback like: `"Payment delayed, retrying later"`
* Log the incident and alert

---

### ğŸ§  Summary

| Category         | Examples                           |
| ---------------- | ---------------------------------- |
| Retry strategies | Polly, Exponential Backoff         |
| Failure handling | Circuit breaker, Fallback          |
| Load protection  | Bulkheads, Rate limiting           |
| Monitoring       | Health checks, Observability tools |

---

Letâ€™s break this down **line by line**, and explain **each parameter** in this `HttpClientFactory` + **Polly resilience policy** configuration in .NET Core:

---

### âœ… Full Code:

```csharp
services.AddHttpClient<IProductService, ProductService>()
    .AddTransientHttpErrorPolicy(policy =>
        policy.WaitAndRetryAsync(3, retryAttempt =>
            TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))
        )
    )
    .AddTransientHttpErrorPolicy(policy =>
        policy.CircuitBreakerAsync(5, TimeSpan.FromSeconds(30))
    );
```

---

## ğŸ§  1. `AddHttpClient<IProductService, ProductService>()`

This tells .NET to:

* Create and inject an `HttpClient` into `ProductService` when it is requested as `IProductService`.
* This is part of **typed clients** in `HttpClientFactory`.

---

## ğŸ” 2. `AddTransientHttpErrorPolicy(...)`

This adds a **resilience policy using Polly** to handle **transient faults**, like:

* 5xx server errors
* 408 request timeouts
* Network failures (e.g. DNS issues)

You can add **multiple** of these policies (as seen above).

---

### ğŸ”‚ Inside `WaitAndRetryAsync(...)`

```csharp
.WaitAndRetryAsync(3, retryAttempt =>
    TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))
)
```

This means:

| Element                     | Meaning                                                                           |
| --------------------------- | --------------------------------------------------------------------------------- |
| `3`                         | Number of retry attempts (**3 times**)                                            |
| `retryAttempt`              | 1st, 2nd, 3rd retry iteration index                                               |
| `Math.Pow(2, retryAttempt)` | **Exponential backoff**: Waits `2^1 = 2s`, `2^2 = 4s`, `2^3 = 8s` between retries |
| `TimeSpan.FromSeconds(...)` | Converts number to a wait delay                                                   |
| `WaitAndRetryAsync(...)`    | Will **retry after a delay** if a transient error occurs                          |

âœ… This helps avoid **hammering the same failed service** over and over.

---

### ğŸ”Œ 3. `.CircuitBreakerAsync(5, TimeSpan.FromSeconds(30))`

```csharp
.CircuitBreakerAsync(5, TimeSpan.FromSeconds(30))
```

| Parameter                  | Meaning                                                                               |
| -------------------------- | ------------------------------------------------------------------------------------- |
| `5`                        | If **5 transient errors** occur in a rowâ€¦                                             |
| `TimeSpan.FromSeconds(30)` | â€¦ then **"open the circuit"** for 30 seconds (i.e. reject all requests)               |
| During 30 seconds          | No outgoing request will be made; you'll immediately get a **BrokenCircuitException** |
| After 30 seconds           | Circuit enters **half-open** state â†’ tries one request                                |
| If successful              | Closes the circuit (normal operation resumes)                                         |
| If fails again             | Re-opens circuit again for 30 seconds                                                 |

âœ… This **protects the failing service** and **avoids wasting resources**.

---

## ğŸ§© ğŸ”„ Summary Diagram

```
Request --> HttpClient --> Policy:
           - Retry: 2s, 4s, 8s
           - Circuit breaker:
               â†³ Fails 5 times â†’ Circuit Open for 30s
               â†³ During open â†’ immediate fail (fallback/error)
```

---

## ğŸ§ª Optional: Add Fallback

You can also chain a `.FallbackAsync(...)` policy to return a default response when all else fails.

---

### ğŸ”¹ 13. What is a **Service Mesh**, and where have you used it?

---

### âœ… **Definition (Layman + Technical)**

A **service mesh** is a dedicated infrastructure layer that **handles service-to-service communication** in a microservices architecture.

Think of it like:

> A **traffic control system** for your microservices â€” managing **routing, retries, encryption, load balancing**, observability, and **security**.

---

### ğŸ§  **Why it Exists**

Without a service mesh, each microservice must handle:

* **Retries & timeouts**
* **TLS/SSL**
* **Logging/tracing**
* **Circuit breaking**
* **Service discovery**
* **Load balancing**

That leads to a **lot of boilerplate** in every service.

A **service mesh** moves all that to a **sidecar proxy** â€” usually Envoy â€” so your services focus purely on business logic.

---

### ğŸ§° Popular Service Mesh Tools

| Tool         | Platform         |
| ------------ | ---------------- |
| **Istio**    | Kubernetes       |
| **Linkerd**  | Kubernetes       |
| **Consul**   | Kubernetes + VMs |
| **NGINX SM** | Hybrid           |

---

### âš™ï¸ How It Works (Simple Flow)

```bash
Client -----> Envoy Sidecar (Proxy) -----> Service A
            <-----<-----<-----<-----<-----
```

Each service **talks to its sidecar proxy**, which then talks to the other serviceâ€™s proxy. The mesh:

* Encrypts traffic (mTLS)
* Tracks requests (telemetry)
* Handles retries/circuit breakers
* Authenticates callers

---

### ğŸ’¡ Where Have I Used It? (Sample Experience)

ğŸ› ï¸ **Scenario:** Youâ€™re working on a .NET Core app deployed in **Azure Kubernetes Service (AKS)**, and use **Istio** to manage microservice communication.

**Use Cases Implemented:**

1. **mTLS Encryption**: All traffic between services is encrypted by default.
2. **Retry Policies**: Handled via Istio configuration instead of code.
3. **Rate Limiting & Quotas**: Controlled who could call certain APIs and how often.
4. **Observability**: Used tools like **Kiali** and **Jaeger** for tracing and traffic graphs.
5. **Canary Deployments**: Split 10% traffic to v2 of the service for live testing.

---

### ğŸ“œ Bonus: Service Mesh vs API Gateway

| Feature         | Service Mesh                     | API Gateway                   |
| --------------- | -------------------------------- | ----------------------------- |
| Purpose         | Service-to-service communication | Client-to-service entry point |
| Works on        | Internal cluster traffic         | External traffic              |
| Example Tool    | Istio, Linkerd                   | Azure API Management, Kong    |
| Sidecar pattern | Yes                              | No                            |

---

### ğŸ”¹ 14. How Do You Manage **Distributed Transactions** in Microservices?

---

### ğŸ§¨ The Problem:

In microservices, each service owns **its own database**. So, a single business operation like *â€œPlace Orderâ€* may span:

* `OrderService` (writes to OrderDB)
* `InventoryService` (updates stock in InventoryDB)
* `PaymentService` (charges money via PaymentDB)

But **distributed 2-phase commits (XA transactions)** don't work well across services â€” they're slow, hard to scale, and not supported in most modern cloud environments like AKS or Azure Cosmos DB.

---

### âœ… The Solution: **Eventual Consistency with Saga Pattern**

Instead of a single transaction, use **a series of local transactions** coordinated across services.

---

## ğŸ§± 1. Saga Pattern (Coordinator of Local Transactions)

There are two types:

### ğŸ” A. **Choreography (Event-Driven Saga)**

No central coordinator. Services **listen and react** to events.

ğŸ“¦ *Example:*

* `OrderService` â†’ publishes `OrderPlaced`
* `InventoryService` â†’ consumes `OrderPlaced`, reserves stock, publishes `StockReserved`
* `PaymentService` â†’ consumes `StockReserved`, charges money, publishes `PaymentSuccess`

â›” Rollback via **compensating actions**, e.g., if payment fails â†’ publish `PaymentFailed` â†’ Inventory rolls back reservation.

âœ” Pros: Simple, scalable
âœ˜ Cons: Complex logic is spread across services

---

### ğŸ¯ B. **Orchestration (Central Controller)**

A **Saga orchestrator** (like [MassTransit](https://masstransit-project.com/) in .NET) **calls services one-by-one** and listens to responses.

ğŸ“¦ *Example:*

```csharp
await OrderService.CreateOrder();
await InventoryService.ReserveStock();
await PaymentService.ChargeCard();
```

If any step fails, orchestrator invokes **compensating commands**.

âœ” Pros: Centralized logic
âœ˜ Cons: Tight coordination

---

## ğŸ’» .NET Implementation Example

Using **MassTransit + RabbitMQ** (Orchestration Saga):

```csharp
public class OrderState : SagaStateMachineInstance
{
    public Guid CorrelationId { get; set; }
    public string CurrentState { get; set; }
    public Guid OrderId { get; set; }
    public DateTime CreatedAt { get; set; }
}
```

```csharp
public class OrderStateMachine : MassTransitStateMachine<OrderState>
{
    public State StockReserved { get; private set; }
    public Event<OrderPlaced> OrderPlacedEvent { get; private set; }

    public OrderStateMachine()
    {
        InstanceState(x => x.CurrentState);
        Event(() => OrderPlacedEvent, x => x.CorrelateById(m => m.Message.OrderId));

        Initially(
            When(OrderPlacedEvent)
                .Then(context => { /* call Inventory */ })
                .TransitionTo(StockReserved)
        );
    }
}
```

---

## âš™ï¸ In Azure Environment (AKS)

* **Message Bus**: Use **Azure Service Bus**, **Event Grid**, or **RabbitMQ**
* **Orchestrator**: Use **MassTransit** or **Dapr Workflows**
* **Compensation**: Write compensating handlers or use state-based coordination

---

## âœ… Best Practices

| Principle                    | Description                                           |
| ---------------------------- | ----------------------------------------------------- |
| ğŸ’¬ Event-Driven              | Favor choreography when processes are loosely coupled |
| ğŸ” Compensating Transactions | Always plan rollback steps                            |
| ğŸ“¦ Idempotency               | Retry-safe commands (PUT, not POST)                   |
| ğŸ” Consistency               | Design for **eventual consistency**, not ACID         |
| ğŸ“Š Monitoring                | Use distributed tracing (e.g., OpenTelemetry)         |

---

Great question, Vatan ğŸ‘¨â€ğŸ’»! Let's go **in-depth** on **Choreography-based Event-Driven Saga**, especially:

> â“ **"If PaymentService fails, how does it roll back OrderService?"**

---

## ğŸ§© First, Quick Recap of Choreography Saga

Each service **acts independently** and **reacts to domain events** from other services.

Thereâ€™s **no central coordinator**; logic is distributed across services.

---

## ğŸ§ª Business Use Case â€“ Placing an Order

Suppose the business flow is:

1. ğŸ§¾ `OrderService`: Creates order â†’ emits `OrderPlaced`
2. ğŸ“¦ `InventoryService`: Listens to `OrderPlaced` â†’ reserves stock â†’ emits `StockReserved`
3. ğŸ’³ `PaymentService`: Listens to `StockReserved` â†’ tries to charge â†’ fails â†’ emits `PaymentFailed`
4. ğŸ” `InventoryService` & `OrderService`: Listen to `PaymentFailed` â†’ undo their work

---

## ğŸ§  Letâ€™s Visualize the Flow (with Events)

```
[User Clicks "Place Order"]
        â†“
OrderService:
    - Create Order (status = Pending)
    - Emit â¡ï¸ Event: "OrderPlaced"
        â†“
InventoryService:
    - Listen "OrderPlaced"
    - Try reserve stock
    - Emit â¡ï¸ Event: "StockReserved"
        â†“
PaymentService:
    - Listen "StockReserved"
    - Try to deduct payment
    - âŒ FAIL!
    - Emit â¡ï¸ Event: "PaymentFailed"
        â†“
InventoryService:
    - Listen "PaymentFailed"
    - Undo stock reservation
        â†“
OrderService:
    - Listen "PaymentFailed"
    - Update order status to "Failed"
```

---

## ğŸ› ï¸ Sample C# Event-Driven Code Snippets

### 1. `OrderPlaced` Event

```csharp
public record OrderPlaced(Guid OrderId, string ProductId, int Quantity, decimal Amount);
```

### 2. `PaymentFailed` Event

```csharp
public record PaymentFailed(Guid OrderId, string Reason);
```

---

### ğŸ‘· `OrderService` â€“ Listens to `PaymentFailed`

```csharp
public class PaymentFailedHandler : IConsumer<PaymentFailed>
{
    public async Task Consume(ConsumeContext<PaymentFailed> context)
    {
        var orderId = context.Message.OrderId;

        var order = await _orderRepo.GetByIdAsync(orderId);
        order.Status = "PaymentFailed";
        await _orderRepo.UpdateAsync(order);

        Console.WriteLine($"[OrderService] Order {orderId} marked as PaymentFailed");
    }
}
```

---

### ğŸ“¦ `InventoryService` â€“ Listens to `PaymentFailed`

```csharp
public class PaymentFailedInventoryHandler : IConsumer<PaymentFailed>
{
    public async Task Consume(ConsumeContext<PaymentFailed> context)
    {
        var orderId = context.Message.OrderId;

        // Undo stock reservation
        await _inventoryService.RestoreStock(orderId);

        Console.WriteLine($"[InventoryService] Stock restored for order {orderId}");
    }
}
```

---

## ğŸ”„ What Is This Called?

This is called a **Compensating Action** â€” undoing a previously successful local transaction because something downstream failed.

---

## ğŸ§± Key Principle

Choreography is about **each service listening to relevant events** and **reacting independently**.

Thatâ€™s why:

* There is **no rollback across services**
* Instead, each service has a **compensation logic** to "reverse" what it did if something fails downstream

---

## âœ… Advantages

| âœ… Benefit              | ğŸ“ Description                      |
| ---------------------- | ----------------------------------- |
| Loose coupling         | No central orchestrator to maintain |
| Highly scalable        | Each service owns its own fate      |
| Simple in simple cases | Fewer dependencies                  |

---

## âš ï¸ Challenges

| âŒ Issue                   | ğŸ’¡ Solution                                                        |
| ------------------------- | ------------------------------------------------------------------ |
| Hard to track flow        | Use distributed tracing (OpenTelemetry)                            |
| Too many events           | Use event naming conventions and centralized event schema registry |
| Compensations get complex | Prefer orchestrated sagas for long-running, stateful workflows     |

---

## ğŸ§  Summary

* In **Choreography-based Sagas**, thereâ€™s **no rollback** like in RDBMS â€” instead:

  * Services emit **events**
  * Others **listen and react**
  * **Compensating actions** manually undo earlier steps
* Payment failure is **notified via event**, and `OrderService` listens to it to cancel the order

---

Excellent question, Vatan! Versioning is **critical** in microservices to avoid breaking existing clients while allowing services to evolve independently.

---

## ğŸš¨ Problem Statement

If your microservice API changes (e.g., modifies or removes a field), **existing consumers may break**.

To **prevent this**, we need to support **multiple API versions** until all consumers migrate.

---

## âœ… Best Practices for API Versioning

| Approach              | Description                                                   | Notes                             |
| --------------------- | ------------------------------------------------------------- | --------------------------------- |
| **URL versioning**    | Add version in the route (`/api/v1/products`)                 | Most common, simple to debug      |
| **Header versioning** | Pass version in a custom HTTP header (e.g., `api-version: 2`) | Cleaner URLs, more flexible       |
| **Query string**      | Use query params (`?v=1.0`)                                   | Less preferred                    |
| **Media-type**        | Use `Accept` header (e.g., `application/vnd.myapp.v1+json`)   | Very RESTful, harder to implement |

---

## ğŸ› ï¸ URL Versioning in ASP.NET Core â€“ Sample

```csharp
[ApiController]
[Route("api/v1/[controller]")]
public class ProductsController : ControllerBase
{
    [HttpGet]
    public IActionResult Get() => Ok("v1 product list");
}
```

```csharp
[ApiController]
[Route("api/v2/[controller]")]
public class ProductsV2Controller : ControllerBase
{
    [HttpGet]
    public IActionResult Get() => Ok("v2 product list with categories");
}
```

### ğŸ”€ Test URLs:

* `GET /api/v1/products` â†’ old version
* `GET /api/v2/products` â†’ new version

---

## ğŸš€ How to Deploy in AKS Without Breaking Clients

1. **Deploy v2 alongside v1**

   * Both versions are part of the container or separate services
2. **Ingress routing** via paths:

   * Use nginx or Application Gateway Ingress Controller (AGIC)
   * Example:

```yaml
paths:
  - path: /api/v1/products
    backend: v1-service
  - path: /api/v2/products
    backend: v2-service
```

3. **Slow rollout**

   * Let some clients use v2
   * Monitor logs/metrics for issues
4. **Deprecate v1** when all clients migrate

---

## ğŸ§  Summary

| Key Principle                   | Notes                                  |
| ------------------------------- | -------------------------------------- |
| Never break existing clients    | Backward compatibility is a must       |
| Keep old versions for some time | Clients may take time to upgrade       |
| URL versioning is simple        | And widely supported                   |
| Header/Media-Type for experts   | More flexible but harder to test/debug |

---

Would you like a **middleware-based version routing system** or a **Swagger integration example** too?
















